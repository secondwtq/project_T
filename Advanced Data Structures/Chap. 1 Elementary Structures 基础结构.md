##Chap. 1 Elementary Structures 基础结构##

---

栈和队列两种非常基础的数据结构一般在 “Progrmming 2”这两门课中讲，此处我们会细讲，并且点出实现中的一些关键问题。双端队列则是对这两种结构更高层次的抽象（但是应用很少）。

###1.1 Stack 栈###

栈是所有数据结构中最简单的（不是数组么），可以说是一种 LIFO 存储。栈支持的基础操作有：压入，弹出，检查是否为空。在编程中，嵌套块、局部变量、递归、baktracking 都和栈有关。栈直接应用到算术表达式求解和回溯找迷宫出路的问题中。

书中给出了理想情况下栈的实现，该实现假设 pop 操作不在空栈中执行，假设没有数组大小和内存的限制。

之后加入了数组边界堆栈溢出的检查，会以返回值的形式给出错误反馈，注意我们此处并不符合栈这种结构的定义，我们限制了它的行为，限制了栈中同时可以存在元素的最大数目。这是所有基于数组的数据结构的基础缺陷：它们的大小/容量是固定的，这个大小需要预先设定，并且无论实际有多少元素，它总是占那么多空间。在 Section 1.5 中我们可以看到系统的避免该缺陷的方法，通常可以使用动态分配的方式。

我们并未检查下标越界问题，这是因为理论上说，上标越界在理想的实现中是不存在的，而下标越界则是因为堆栈的打开方式不对。我们对安全检查的策略是，仅包括由于**实现的限制**所需的检查，同时**假定使用者的操作是正确的**，假定内存资源无限。

我们还加入了一个有用的 top() 函数，返回栈顶对象但是并不弹出。考虑到一个程序中可能存在很多堆栈，我们需要允许动态创建堆栈（虽然原作者的态度貌似不是很好，但是这里加个 object 应该好一点），因此做了一个 struct 来存储堆栈的信息，并且在函数中加入了相应的参数（姑且理解为 OO）。

另一个栈的实现是使用动态分配的链表，在头部做一个 dummy node，然后在头部进行增删节点操作。书中的实现引用了 get_node 和 return_node 两个外部函数。注意由于 pop 和 destruct 时需要释放节点（姑且这么认为，但是总之那个节点会无效）因此需要先执行拷贝以返回/执行以后的操作。这样的栈不限大小（依然忽略内存资源限制），缺点是速度慢（并不是因为指针，而是 cache 的问题）。

我们还有一种结合数组和链表优势的方法：***使用一个包含一个数组的块的链表。***（貌似这个东西学名叫 block array）这个实现中的栈 struct 加入了一个 previous 指针指向上一个 block，允许用户指定每个 block 大小，block 中的数组依然是另外动态分配的。（从某种意义上来说相当于一个倒着的链表，push 时这个新建节点，复制的过程很神奇，最后把 previous 指向上一个新建的复制目标节点，这样便不用改变客户程序中的 stack 指针）

在基于数组的实现中，几乎所有操作都是常数时间的。基于链表的实现中，push/pop 的时间依赖于 get_node 和 return_node 的实现，Section 1.4 会讨论这一问题。block list 实现中，操作时间依赖于 malloc 和 free 两个标准函数（最蛋疼的情况是有很多处于块边界上的 push/pop），结论是结合增加的复杂度，可能的最坏情况，这个 block list 的 trade off 可能并不值。create_stack 是常数时间的，remove_stack 应该是线性时间的。

###1.2 Queue 队列###

队列和数组基本是一样的，除了是 FIFO 的，而且要注意队列中序列的两头均可操作，因此实际上要稍微复杂一点。在按顺序管理任务时很有用，也是 BFS 的基础结构。队列滋瓷的基础操作有：enqueue、dequeue、empty。

鉴于队列的特殊问题，如果使用数组实现的话，数组中被使用的部分实际上是不断移动的，理想状况下数组是无限的，这不会造成问题，但是实际中数组有容量限制，因此需要对索引进行取模操作。所以我们说队列的数组实现是有内在的缺陷的（同样也受容量的（更多的）限制，并且数组实现的队列占用了多余的空间）。

动态分配的**链表**可以作为比较好的替代实现：

* 最简单的实现。有两个问题：第一需要一个和 node 不同的专门 struct（存储一个 remove 指针，一个 insert 指针）作为入口，第二，空队列的操作也需要专门处理。

* 改为**循环链表**。这样并不需要使用两个指针来表示入口，只要一个指针指向 insert 节点，其 next 为 remove 节点，直接重用节点 struct 即可。之后在循环链表中加入一个 placeholder 节点，这样 enqueue 便不需要处理特殊情况。

* 第三种实现，也可以使用**双链表**解决 initial 的问题。双链表的节点本身就有两个指针可以作为 remove 和 insert。

**分析：**三个基本操作全部是常数。ctor 和 dtor 依赖于系统内存分配机制（对于基于链表的队列来说删除为 O(n)）。