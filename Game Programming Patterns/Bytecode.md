##字节码模式##
---
####游戏编程模式 - 行为模式####

###功能主治###

通过将其编码为虚拟机的指令，给行为以数据的灵活性。

###适应症###

制作游戏可能比较有趣，但肯定不容易。现代游戏需要大量复杂的代码，又处于主机厂商和应用管理者的严格管控之下，一个小小的 crash bug 就可以让你的游戏无法上市。同时我们还必须榨干平台的剩余价值，为了跟上竞争的节奏而不停的优化。为了能满足高稳定性和性能的需求，我们最后选择了 C++ 这样既有有利于利用硬件的底层表示法，也有丰富类型系统来避免 bug 的重量级语言。我们为自己在这方面的才华而自豪，但是也是有一定代价的。在经历若干时间的训练称为一个熟练的码农之后，我们必须想办法应付自己亲手搭建的庞大的系统框架。而在这一坨一坨的难度上面，作为自身的特殊性，游戏开发还有一个更大的挑战——游戏性。玩家要求游戏做的既艺术又“平衡”，比如中国必须最强，之类之类。但是这要求大量的迭代，如果每个人都在大量的低级代码中 tuning，之后等待漫长的编译过程的话，你的创造力无疑会被扼杀。

####魔战不休！####

假设我们正在制作一个基于魔法的格斗游戏，就是一堆的巫师四处乱跑最后想办法分出个胜负。我们可以在代码中定义好咒语，但是这么做也就意味着每次修改咒语都要有工程师在场，如果设计师想要调整几个参数试试感觉的话，那就必须重编译整个游戏，重新启动，然后再进行战斗。

而现在的游戏在上市之后，还需要不断的更新完善，修复 bug，添加新内容。如果所有的咒语都是硬编码的，那么更新咒语就意味着必须要直接给游戏可执行文件打补丁。而如果把眼光放的更远，我们要支持 ___modding___ 的话，要让用户可以创建自己的咒语，如果把它们放在代码里，那就是说每个 modder 都需要弄一套完整的编译环境，而我们也必须开放源码，如果他们自己写的咒语中有 bug，还会导致严重的 crash。

####将中心转移到经济建设上####

很明显使用实现引擎的语言去做这个东西不是很合适，我们需要让咒语在核心游戏中被沙盒完善地封装起来，容易修改，重新载入。并且在物理上与可执行文件隔离。

我不知道看到这些你会怎么想，但是对于我来说这种东西很像是_数据_。如果我们可以在单独的数据文件中定义行为，游戏引擎设法载入并“执行”它，那么我们就可以达到上面所有的目标了。

现在我们只需要弄清楚，对于数据这么一种东西来说，“执行”是什么意思？如何在文件中用字节来表示行为？要做到这一点，有若干种方法。大概你看到这已经知道这种模式到底怎样，尤其是有另外一种模式作为对比：___解释器模式___。

####解释器模式####

我可以在这个模式上面再写一整节，但是原书已经替我把这事情干了。所以这里仅仅要做最简短的介绍。首先是有关编程语言，编程语言本质上是你想要执行的东西。比如对于这种算术表达式的支持：`(1 + 2) * (3 - 4)`。你会把这个表达式中的每一部分分开，和编程语言中的语法对应起来，并转换为_对象_。在该例中，四个数值常量就是四个对象，这是对于原始值的简单包装。而操作符同理也是对象，并且应该保存对于其操作数的引用。再考虑进括号和优先级的因素，就形成了一个小型的对象树。

_奇妙之处到底在哪里？就是__分析__。分析器将一个字符串变成一个包含代表文本结构的对象的__抽象语法树__。把这些搞懂了，你就能写出半个编译器了。_

解释器模式并不是关于_创建_树的，而是关于_执行_树的。这个模式工作的方式很巧妙，树中的每个对象都是一个表达式或子表达式，在真正的面向对象方式里面，我们会让表达式自己进行求值。

首先，我们定义一个表达式的接口：

    class Expression {
        public:
            virtual ~Expression() { }
            virtual double evaluate() = 0;
    };

然后针对我们语言的语法中的每一类表达式，定义一个实现该接口的类，最简单的就是数值：

    class NumberExpression : public Expression {
        public:
            NumberExpression(double value) : value_(value) { }
            
            virtual double evaluate() { return value_; }
            
        private:
            double value_;
    };
    
数值常量表达式自身就等于自身的值，而进行运算则稍微复杂一些，因为涉及到了子表达式。在运算自身的值之前，它们需要先递归执行子表达式：

    class AdditionExpression : public Expression {
        public:
            AdditionExpression(Expression *left, Expression *right) : left_(left), right_(right) { }
            
            virtual double evaluate() {
                //  Evaluate the operands.
                double left = left_->evaluate();
                double right = right_->evaluate();
                
                //  Add them.
                return left + right;
            }
        
        private:
            Expression *left_;
            Expression *right_;
    };
    
这种方式很干净，仅仅是若干简单的类，就可以实现复杂算术表达式的求值。我们现在只需要创建适合的对象，并将它们连接起来。这种模式优雅，简单，但是也有一些问题。比如那个对象框图，你只能看到大量的小方块和它们中间大量的箭头，代码以大量小对象构成的碎片化的树来表示，最后造成了若干不太愿意看到的后果：

载入的时候需要创建并连接大量的小对象，而对象自身，以及用来连接它们的指针，还有 vptr 使用了大量的内存，对子表达式的递归，虚函数调用也不是缓存友好的。

最后你发现了什么：慢。这也就是大部分主流编程语言不是基于解释器模式的原因，太慢了，而且占了太多的内存。

_关于缓存问题，详见___数据本地化___一节。Ruby 一开始用这种方式实现，持续了 15 年之后，在 1.9 版中，换用了本章描述的字节码模式。_

####机器代码，当然是虚的####

现在再考虑我们的游戏，当玩家运行的时候，电脑不需要遍历复杂的 C++ 语法树，而是由我们在之前编译成机器代码，玩家的 CPU 直接执行它。而这种方式好在哪里？

首先它的信息是稠密的，是完全的字节码，没有一个二进制位被浪费；再次是线性的，除流程控制之外，没有在内存中的跳转；它也比较底层且快速。所以我们才使用这种方式，但是对于咒语来讲，我们并不需要真正的机器码，当游戏执行的时候，用户单独提供机器码，这会有很大的安全隐患。所以我们需要在机器码的性能和解释器模式的安全之间取一个折衷。

这样我们不去载入执行真正的机器码，而是定义自己的_虚拟_机器码。我们会在游戏里面写一个小的模拟器，这样和机器码就差不多了，稠密，线性，相对也比较底层，而它又是全部由我们的游戏操控的，这就相当于一个沙箱。我们把这个小型模拟器叫做_虚拟机_（或者简称 VM），并且把我们自己搞出的二进制机器码叫做_字节码_。

_这也就是为什么 iOS 和许多游戏主机不允许程序在执行运行时载入或生成的机器码，这大概是编译器应该干的事情。它们包含一个 JIT 编译器，在运行时把程序代码变成优化过的机器码。_

_在程序语言圈子里面，“虚拟机” 和 “解释器” 实际上是一样了，在这里我的叙述里面，这两者也是可互换的。但是当我特指原书中的解释器模式时，我会加上“模式”一词来区分。_

乍一看搞起来很难，本节下面的部分，我想论证如果你控制好自己的功能列表的话，这是完全可行的。就算你自己不去使用这个模式，至少也能对 Lua 和其他使用该模式实现的语言有一个更好的理解。

###用法用量###

定义一个定义底层操作的指令集，由字节序列编码。而虚拟机负责执行指令，可能会借助一个立即数堆栈。通过指令的组合来定义复杂的行为。

###注意事项###

这是本书中最最最复杂的模式，而且也不是轻易就能扔进你的游戏中的。当你有大量的行为需要定义，并且用来实现游戏的语言因为太底层，容易出错，编译太慢或工具太落后难以迭代，需要沙箱等情况不适合定义行为时使用该模式。当然还是要更多地考虑实际情况，字节码可以带来更快速的迭代过程和更好的安全性，但是终究比本地代码要慢，所以对于引擎中性能比较关键的部分不是很适合。

###不良反应###

创造自己的语言，在已有的系统中搭建另一个系统，这种事情让人很激动。我在这里会使用最小最简单的例子，但是在实际开发中往往没有这么简单。我看到的情况总是，每次有人要定义一个小型语言，或者脚本系统时都会说，别急，这东西不大。而到最后不可避免地，大量的小功能添加进去，最后成了一个全功能语言（某些模板语言就是很好的例子）。当然，开发全功能语言，这种事情本来是没错的，但是前提是你有意这么去做，否则就控制好语言的范围，避免到最后走得太偏。

####你需要一个前端####

底层字节码对于性能来说很有帮助，但是你不会亲手去写二进制字节码。本来我们把行为从代码中移出来的原因之一就是寻求一个_更高层_的表示形式。如果你觉得 C++ 太底层的话，那可以让用户用汇编语言去写，我没意见。

这一点上和原书中的解释器模式一样，你需要设法_生成_字节码。一般来说，用户会使用某些高级的格式来定义行为，然后用一个工具转换成虚拟机能看懂的字节码，也就是编译器。这种事情看起来很可怕——所以我才要特别拿出来提。如果你没有这种资源的话，字节码模式不适合你，但是后面你也许会发现事情没那么糟。

_有一个例外，就是某个叫做 RoboWar 的古老游戏。在这个游戏里面，玩家用一种类似汇编，十分近似于我们现在要讨论的那种指令集的语言写小程序来控制机器人。我通过这个游戏，邂逅了（类）汇编语言。_

####你会想念调试器的####

编程是一件苦难的事情，我们一般都知道我们想要做什么，但是却不能准确地把自己的意思传达给机器。为了更好地寻找和修复我们表达中的 bug，我们发明了一堆工具。比如调试器，静态分析器，反编译器，等灯等灯。所有这类工具都是为某种特定语言设计的，有可能是某种机器码，或者更高层的语言。

而如果你自己定义了一套虚拟机字节码，那同时也就放弃了所有的工具。如果你定义的行为比较简单的话，那也许不需要太多的工具，但是随着内容的规模增加，也许就有必要花时间做一些对用户理解它们的字节码到底在干什么有帮助的事情了，这种东西可能不会随游戏上市（特指那些无视 modder 的傻逼游戏），但是却直接关系到游戏能否上市。

###患者现身说法###

在看过前面几节之后再看到实现，也许你会被它的简单直接吓得头飞到天上，屁股坐到了地上。首先，我们需要为虚拟机设计一套指令集，在考虑字节码之类的事情之前，我们首先看一些更高层的类似物，比如 API。

####神奇的 API####

设想直接在 C++ 代码中定义咒语，我们需要调用哪些 API 呢？

大多数咒语都是对巫师某种状态的改变：

    void setHealth(int wizard, int amount);
    void setWisdom(int wizard, int amount);
    void setAgility(int wizard, int amount);

第一个参数指定目标巫师，比如 0 是玩家，1 是对方。这样加血咒语对玩家自己的巫师有效，伤害对敌人有效。这三个小方法就囊括了许多种类的魔法。

但是这还不够，咒语总要装装逼，没人喜欢不拍照不讲话不盖房子的官：

    void playSound(int soundId);
    void spawnParticles(int particleType);
    
这些和游戏性无关，但是和_游戏体验_关系很大，我们还可以加入其他关于视角震动，动画之类的 API，但是对于举例子来说，这些足够了。

####神奇的指令集####

####堆栈机####

####行为即组合####

如果你用一个编程语言的眼光来看我们的小型虚拟机的话，现在它支持的只有一小撮内置函数和常量参数，想要更靠近“行为”，我们还需要组合。设计师希望有能把不同的值以各种方式组合的表达式，简单来说，要能实现一种将状态用一定的量修改，而不是修改为一定量的魔法。这也就是说需要考虑状态当前的值，我们现在已经有复写状态的指令了，现在我们还需要加入一些读取状态的指令：

    case INST_GET_HEALTH: {
        int wizard = pop();
        push(getHealth(wizard));
        break;
    }
    case INST_GET_WISDOM:
    case INST_GET_AGILITY:
        //  You get the idea...

你会发现它对堆栈的操作是双向的，它会从堆栈中弹出一个值作为参数，之后把结果压回堆栈中。这样我们就可以获得状态，之后创建类似于把巫师的敏捷和智慧统一之类的咒语了。但是现在功能还是比较受限，我们还需要算术操作，宝贝儿虚拟机还不会 1 + 1 呢。现在需要再加入一点指令，大概你也能猜出怎么写了，比如加法：

    case INST_ADD: {
        int b = pop();
        int a = pop();
        push(a + b);
        break;
    }
    
到目前为止，这些基础指令每多添加一个，字节码的可扩展性就增长一步。表面上看没什么，但是我们现在已经有可能处理所有复杂的深层嵌套的算术表达式了。现在我们看一个稍微复杂一点的例子，一个给玩家的巫师补充敏捷和智慧的平均数的血的咒语：

    setHealth(0, getHealth(0) + (getAgility(0) + getWisdom(0)) / 2)
    
看到这个你第一反应也许是需要加入额外的指令来处理表达式的括号分组，但是实际上堆栈已经提供了隐式的支持，具体的实验操作是这样的：

 1. 获取巫师当前的血量、敏捷和智慧，分别放于试管中。
 2. 取敏捷和智慧混合，加入“加”溶液，在试管中充分反应。
 3. 将 2 中得到的混合物除 2。
 4. 取血量，加入 3 中溶液和“加”溶液，充分反应。
 5. 将 4 中溶液放入巫师血量槽中。
 
其中每一个“放入试管”实际都代表压入堆栈，而“取”都代表弹出。这样我们就很容易把这些翻译为机器码。在下面我会给出翻译完成后的结果。为了表述清晰，假设巫师当前的状态是 45 血，7 敏捷，11 智慧，我也会把每一行执行后的堆栈状况表示出来以展示堆栈变化，同时附带一行小注释。

    LITERAL 0		[0]				# Wizard index
    LITERAL 0		[0, 0]			# Wizard index
    GET_HEALTH		[0, 45]			# getHealth()
    LITERAL 0		[0, 45, 0]		# Wizard index
    GET_AGILITY		[0, 45, 7]		# getAgility
    LITERAL 0		[0, 45, 7, 0]	# Wizard index
    GET_WISDOM		[0, 45, 7, 11]	# getWisdom()
    ADD				[0, 45, 18]		# Add agility and wisdom
    LITERAL 2 		[0, 45, 18, 2]	# Divisor
    DIVIDE			[0, 45, 9]		# Average agility and wisdon
    ADD				[0, 54]			# Add average to current health
    SET_HEALTH		[]				# Set health to result
    
如果你观察每一步的堆栈变化，你可以发现这个数据流就很像是魔法，一开始我们向其中压入了一个 0，那货在整个过程中一直就在后面打酱油，直到最后一个 SET_HEALTH 指令。

_可能我在这里对 “魔法” 的品味太 low 了点。_

####虚拟机####

我可以一直加入更多的指令，但是现在已经足够了。我们现在已经有了一个可以用简单紧凑的数据格式定义开放行为的小型虚拟机。现在你可以发现“字节码”和“虚拟机”这种次看上去很吓人，但撤屏视之，一堆栈，一循环，一分支，一抚尺而已。

而至于我们一开始想要把行为用沙箱包装的目的，在看到了虚拟机的实现之后就会发现，字节码不能进行任何的恶意行为，它根本无法越出游戏引擎的界限。我们可以通过控制堆栈的大小来控制内存使用，同时注意不要出现 stack overflow，甚至可以控制运行效率。现在只有一个问题没有解决：字节码的实际创建。我们之前都是先弄一些伪代码，之后手动“编译”成字节码，很明显这么干很耗时，不切实际。

_在我们的例子中，控制运行时间并不太必要，因为我们并没有任何涉及循环的指令。这样我们可以通过限制字节码的总大小来限制执行时间。当然这也意味着我们的字节码并不是图灵完全的。_

####定义魔法的魔法####

我们最开始的目标是一种更高级的定义行为的模式，但是到现在我们做出的东西比 C++ 还要低级。虽然满足了对运行时性能和安全性的要求，但是对于设计显然不够友好。为了弥补这一缺陷，我们需要在工具上面下点功夫，也就是需要一个让用户定义魔法行为，生成底层堆栈机器字节码的工具。

这玩意表面上比做虚拟机还难。许多专业的程序猿在大学都被拉去过上编译器的课，基本啥也没学到——除了对于一本封面上有龙的书和 lex，yacc 之类名词的 PTSD。

_我在这里当然是指经典的 ___编译器：理论，方法和工具___。_

实际上编译基于文本的语言并没有这么可怕，只是在这里不大方便提。但是实际上你也不一定非得这么做，我们需要的仅仅是一个工具，不一定非得是输入是源代码，输出是机器码的那种编译器。

我觉得更合适的解决方案应该是试图做一套让用户，尤其是并不是那么技术化的用户，定义自己的行为的图形界面。也就是一个让用户通过点击拖动小方块，菜单项或者所有类似行为来“编程”的应用。这样就避免了文本中必然可能出现的语法错误，和自己写的编译器对领导瞎指挥的礼貌问题。遇到不可用的情况仅仅需要禁用相应的界面元素，或者提供默认值，这样无效情况就少了很多。当然可能对你来说写图形界面比写编译器还蛋疼，那我就没辙了，你好自为之。

_我给 Henry Hatsworth and the Puzzling Adventure 写的脚本系统就很像这玩意。_

_我在这里想强调一下错误处理的重要性。作为程序猿，我们一般会把人犯的错误看成耻辱，并且自己尽量避免这种错误。但是要建造一套让用户喜欢的系统，你就必须面对人性，包括人性中的黑暗面。人犯错误，是很正常的事情，有些时候也是创造过程中必要的东西。提供一些优雅地处理错误的功能（比如撤销）能提高用户的创造力，最后才会有生产力。_

我们的最终目的是以一种对用户友好的高层的形式来表达行为，所以其中有用户体验的因素。而要有效地执行行为，你又需要把它翻译成一种底层的形式。这些都需要下功夫，但是如果你愿意接受挑战的话，那也会是值得的。

###药物相互作用###

我尽力把这一节写的简单一点，但是我们现在做的是创造一种新的语言，在这个角度上讲，越开放越好。纠结这货总问题很有趣，但是注意别忘了游戏的 deadline。

_我好像没能达到目的，这是本书中最长的一节。（翻译君也泪目了 QaQ）_

####指令如何访问堆栈？####

如同豆腐脑有甜党和咸党，字节码虚拟机主要有基于堆栈的和基于寄存器的。在基于堆栈的虚拟机中，指令会操作堆栈顶端的数据，比如在我们的例子中，INST_ADD 会弹出两个值，做加操作并把结果压入。而基于寄存器的虚拟机依然有堆栈，唯一的区别就是指令可以从堆栈的更深处读取输入，INST_ADD 可以不只是以弹出的方式获取操作数，而是用两个存储在字节码中的索引来标志从堆栈的什么地方读取操作数。

* 堆栈式虚拟机的指令较小，因为其指令往往是隐式从堆栈顶取参数的，不需要额外编码任何数据，这样很多指令用一个字节就能表示。生成代码也比较简单。但是指令数目会多一些，比如对于 a = b + c 来说，你需要额外的指令把操作数移到堆栈顶端，再把结果移到 a 处。

* 寄存器式虚拟机的指令较长，一般需要堆栈偏移量的参数。比如 Lua 的虚拟机，大概是最著名的寄存器虚拟机了，一条指令占了整整 32 位，其中 6 位是指令的类型，剩下的全都是参数。而指令数目较少，因为每条指令能做的事情更多了。有些人也认为这样性能更好，因为不需要太过纠结于堆栈的问题。

_Lua 从来没有规范过字节码，它那个字节码的格式每个版本都会变。我现在所讲的是针对于 Lua 5.1 版的，___这个文档___可以帮助你更好地理解 Lua 的内部原理。_

那么该选择哪一个呢？我个人的意见是依然选择基于堆栈的虚拟机，因为这个实现起来更简单，代码生成也简单。在 Lua 之后，寄存器式虚拟机看上去稍微快一点，但是实际上性能是取决于指令本身和虚拟机的许多其他细节的。

####有哪些指令？####

指令集定义了哪些可以，哪些不可以用字节码来表示的范围，而且对于虚拟机的性能也很重要。下面是几种可能需要的指令列表：

* 外部元素。这是虚拟机与外部游戏引擎的接口，控制字节码能够表示的实际行为，做一些用户能够看到的事情。没有外部元素的话，虚拟机就是用来浪费资源逗你玩的。

* 内部元素。用来操作虚拟机内部的值，比如常量，算术操作，比较运算符，用来操作堆栈的指令等。

* 控制流。我们的例子并没有涉及到控制流，但是当你需要条件式的执行指令，或者循环，以及多次执行的时候，就需要控制流了。而对于字节码这种比较低级的玩意来说也很简单——跳转，也就是 goto。你可以基于这一个额外的功能做出所有的高层控制流。

* 抽象。如果数据中定义了大量的东西，可能就会出现需要重用某些字节码的情况，这时如果没有抽象就只能复制粘贴，而实际上可以通过调用函数等抽象方法优雅地解决这个问题。最简单的函数调用并不比跳转要复杂多少，唯一的区别是虚拟机需要维护另一个_调用堆栈_。当执行到一个“call”指令时，虚拟机需要把当前的指令索引压入返回堆栈中，然后跳到被调用的地方；当执行到“return”时，虚拟机将索引弹出并跳回原位置。

####值如何表示？####

上面示例中的虚拟机仅仅与一种值打交道——整数。这种性质让虚拟机本身很简单，堆栈仅仅是整数的堆栈。但是完成度更高的虚拟机需要支持不同的数据类型，字符串，对象，集合，等等。你需要确定它们在内部是如何存储的。

* 唯一的数据类型。这样很简单，不需要操心任何关于标签，类型检查，类型转换的事情。但是也完全限制了处理不同数据类型的能力。

* 以标签区分的多数据类型。这时动态类型语言常用的方式之一，每一个值由两部分组成，第一部分是一个类型标签，一般是以枚举的方式表示，用于区分存储的是什么类型的值。剩下的空间则根据类型，以一定的规则解释：

        enum ValueType {
        	TYPE_INT,
        	TYPE_DOUBLE,
        	TYPE_STRING
        };
        
        struct Value {
        	ValueType type;
        	union {
        		int intValue;
        		double doubleValue;
        		char *stringValue;
        	};
        };

    这样做的好处在于，每个值都明确地知道是什么类型以进行动态委派，但是也耗费了更多的内存。

* 无标签的集合。这种方式也和上一方案一样用了一个类似的联合，但是并没有类型标签。而你自己需要想办法确保正确的操作被应用到了正确的值上。这就是静态类型语言表示对象的方法，静态类型系统在编译时将所有东西确定下来，在运行时就不必单独检查（也是汇编和 Forth 这种_无类型_语言使用的手段，这种语言将确保操作与值类型统一的责任留给了用户）。这么做的好处是非常紧凑，也比较高效，但付出的代价是不安全（更可怕的是某些居心不良的资本主义走狗可能会篡改/炮制有害的字节码，这也是 JVM 在载入时要进行字节码校验的原因）。

* 接口。这是一种面向对象的解决方案，可能也是仅有的几种通过多态来实现的奇葩方案之一。我们定义一个提供若干类型检查和转换虚函数的接口：

        class Value {
            public:
                virtual ~Value() { }
                virtual ValueType type() = 0;
                virtual int asInt() {
                    //  Can only call this on ints.
                    assert(false);
                    return 0;
                }
                
                // Other conversion methods...
        };
    
    然后你需要为每一个数据类型创建一个具体类：
    
        class IntValue : public Value {
        	public:
        		IntValue(int value) : value_(value) { }
        
        		virtual ValueType type() { return TYPE_INT; }
        
        		virtual int asInt() { return value_; }
        
        	private:
        		int value_;
        };
 
     这种做法比较开放，因为你可以在有了基础接口的前提在，在核心虚拟机以外定义新的值类型，并且是面向对象的，使用动态委派来实现类型特定行为比类型标签更夫和面向对象教徒们的想法。但是又臭又长，并且效率较低。在类似虚拟机核心这样的地方，小的性能损失会大量积累，实际上这已经和解释器模式差不了多少了。
 
我个人的意见是如果你能仅仅做一个数据类型的话没什么。或者也可以另外做一个有标签的集合，这也是大部分语言解释器的做法。

####字节码如何生成？####

——我把最重要的问题留到了最后。我已经告诉你如何解释字节码了，但是你需要做出点东西来产生字节码。传统的做法是写一个编译器，但这不是唯一的选择。

* 如果你定义一种基于文字的语言的话。那你需要单独定义一套语法，实际上无论业余还是专业的语言设计者都难以完全明白这到底有多难，语法设计其实就是用户体验设计。定义一套适合做分析器的语法很容易，定义一套适合拿来做事的语法却很难，尤其是你还把用户限制在了枯燥的文字中。然后你需要实现一个分析器，实际上这个过程不像你想的这么困难，你可以使用 ANTLR 或者 Bison 这样的分析器生成器，或者用递归方法自己写一个。之后你需要考虑如何处理语法错误，这是这个过程中最重要并且最困难的一环，你需要在用户犯语法或语义错误时给出有帮助的反馈信息。另外需要考虑的一点是，这样做出来的成品看起来门槛可能会比较高，虽然对于我们来说文本+终端能简单快捷地解决一切事情，但是非码农往往不这么想。

* 如果设计一个图形工具的话。那你需要实现一套用户界面，按钮，点击，拖放，这些东西，有些人可能感到害怕，但是我个人非常喜欢。但是如果你要这么做的话就要认真去做，当成工作中的重点而不是一个令人不爽的任务，因为任何一点额外的工作都能让你的工具体验更好，并且直接提高游戏的内容质量，如果你研究一下许多喜欢的游戏的背后的话，一定会在制作工具上发现一些秘密。

    采用这种方案你在错误处理上下的功夫会稍微少一点，因为你可以利用图形界面引导用户远离错误。但是可移植性会差一些，在建造图形界面时需要选择框架，大多数框架是专用于某一平台的，虽然也有一些跨平台框架，但很多时候是以牺牲易用性为代价的。

###附录###

* 这个模式和原书中的___解释器模式___很相近。它们都提供了一种以数据的形式表示组合行为的途径。而在实践中你可能两种都在使用，你用来生成字节码的工具中也会有一个代表代码的内部对象树。这就属于解释器模式了。

    要编译字节码，你需要递归遍历该树，和解释器模式中的解释是一样的，唯一的区别在于，字节码模式不是立刻执行行为，而是输出字节码指令备用。
    
* ___Lua___ 编程语言是游戏中使用最广泛的脚本语言。它内部是用一个基于寄存器的非常简练的字节码虚拟机实现的。___Kismet___ 是内置于 Unreal 引擎编辑器 UnrealEd 的一个图形脚本工具。而我自己的小型脚本语言，___Wren___，是一个基于堆栈的简单字节码解释器。