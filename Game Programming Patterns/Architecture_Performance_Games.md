##架构，性能与游戏##
---
####游戏编程模式 - 导引####

在我们入坑之前，我觉得应该先介绍一些我对软件架构，以及其如何应用到游戏中的理解。本节的内容能帮助你更好的理解本书的其他内容——就算确实不能，至少也能给你在类似“如何评价设计模式？”，“如何正确地使用设计模式？”这样的问题中打一些底气。当然，我本人对你的任何立场都不持任何意见。

###什么是软件架构？###

就算你把这本书从头读到尾，也不会获得任何有关于 3D 图形所需的线性代数，物理模拟所需的微积分的知识，也不会教你如何调试你的 AI 行为树，或者如何模拟房间内的声音回响。

这本书是有关于这些功能*之间*的代码的。相对于编写代码，本书更侧重于*组织*代码。实际上，就算最简单/糟糕的程序也有一定程度的代码组织。我们将更多地着手于如何实现*优良*的组织上。

那么，什么是好的架构，什么又是差的呢？

我纠结这个问题，已经有五年了。不过我们也许有一个共同点，就是对于好的设计有一种“直觉”。我觉得你一定和我一样，曾经是低劣设计的受害者。当然，我们也一定应该为其中的一部分负直接责任。

我们之中呢，也有一部分异端，一开始就有在优秀设计的基础上工作的条件。这种代码看上去简直就像朝鲜一样，人人都向往。那么它们的区别到底在哪里呢？

###什么是优良的软件架构？###

对于我来说，在为拥有好的架构的软件进行维护或扩展功能时，会发现代码就像预料到必然有这样的更改一样。只需要添加几个简单的函数调用，不会激起大的涟漪。

“不错哦”

看上去不错，听起来不错，闻着也不错，尝尝更不错。

就是做起来不好做。

另一方面，最关键的一点是，架构就是面向改变的，对于基础的代码，总要有人去维护修改，如果没人去碰的话（无论是因为太完美还是太垃圾），那是没有意义的。而衡量设计的标准，就是变化的难易。如果没有变化的话，那工程就是永远不迈出第一步的运动员了，完全无法继续。

###如何进行改变？###

在添加功能，修复 Bug等修改代码的过程进行之前，你首先需要理解已有的代码。一般来说你不需要完全理解整个程序，但是把相关的部分过一遍是必要的。

这个过程很容易被忽视，但是它也往往是最耗时的部分。如果你觉得把数据从内存保存到硬盘很慢的话，你可以试试把它从你的视网膜保存到大脑里面。

在你有一个大致的概念之后，你就可以撕开解决方案了，着个过程往往是十分纠结的，也常常是很直接的。当你理解了问题和相关的代码后，实现也就不太重要了。

在你用你胖乎乎的手指敲击了一会键盘，之后看到通过了之后，你觉得结束了么？在你编写测试，提交代码之前，你需要做一些清理工作。

你向游戏里面添加了更多的代码，而你应该不会希望下一个修改者会对你的更改感到困惑。为了让你的代码融合的更好，只要不是非常小的更改，一般都会涉及到对架构的一些修改。在这方面做的很好的标准是：下一个修改者压根看不出哪些代码是一开始的，而哪些代码是后来添加的。

###解构的意义在哪里？###

我觉得对于软件架构来说，更大的意义应该在于学习理解代码上。为了简化理解代码的过程，我们有必要思考专门的解决方案——就是设计模式。本书在解构方面有完整的这方面的章节，以及相关的若干设计模式。

对于解构，有多种定义方式，在我来看是这样的：两端代码是耦合的，就意味着如果你要理解其中一段，就必须再去读懂另一段——而其中只有一段是与问题有直接关系的——但是如果着两段代码解构了，你就可以独立地理解两段代码。

我认为的软件架构的核心目标是：集中力量进行社会主义现代化建设，解放和发展生产力，消灭剥削，消灭两极分化，最终实现共同富裕rtjhrtnhow4t89tjojor errp;wer

喂喂喂放开我我好好翻译还不行么...

__最小化你在 make contribution 之前所需了解的知识。__

而对于其后的实现阶段，有另一个对于解构的定义：对于某个部分代码的进行更改，不必更改其他部分的代码。显然很多时候我们需要更高一些东西，但是耦合度越低，就意味着更改对其他部分造成的影响越小。

###我们付出了什么？###

上面的一切看起来都很不错。

把一切都解构，然后，纵享丝滑。

差不多这也是人们为了 抽象，模块化，设计模式，软件架构 之类东西而疯狂的原因。为一个架构优秀的程序编码的体验是非常愉♂悦而高效的。这个直接关系到生产力。

但是这并不是没有代价的。好的设计需要努力。你做的每次修改都需要注意将其优雅地融合到原来的系统里面去，你还需要想办法组织代码，并在大量的小修小改中，维护原来清晰的架构。

其中的第二部分——设计的维护，在此需要特别的注意。很多时候往往开头是很优雅的，然而却在一次又一次的“只是一点小问题”中被毁灭了。

你需要思考程序中的哪些部分需要解构，引入抽象。你还需要考虑未来的可扩展性。人们为了这些事情而疯狂，希望以后的维护者看到的代码是开放，强大而且容易扩展的。甚至想像用一种引擎来完成一切。

然而这才是困难的开始。每当你加入一层抽象，或加入一个扩展点时，你仅仅是_猜测_自己以后需要这层灵活性，并且为例的项目增加了更多的代码，以及复杂性，这将影响开发、调试和维护。

如果你的猜测是对的，那么你的付出确实是有价值的。然而你不得不承认的是，预测未来不那么简单。当抽象没有好处时，它的坏处也就暴露出来了。至少它会给你遗留更多的代码。

当这份疯狂变为狂热时，你最后得到的基础代码架构就失去了控制——到处都是接口和抽象，插件系统，抽象基类，虚函数和扩展点。

处理这些将花费很长的时间，最后你将很少能见到有用的代码。当你改变代码时，各种接口也许会有一些帮助——如果你能找到的话。理论上解构能减少你需要理解的代码量，但是在这种情况下，你会需要额外地理解大量的抽象层。

这样的代码容易让人们对“软件架构”这种东西产生反感情绪，设计模式首当其冲。在混乱的代码中，人们极易忘记它们的本意是制作一个_游戏_，无数长期开发“引擎”的开发者对于扩展性的盲目崇拜，最后导致它们自己都无法指出自己开发的引擎究竟是做什么的。

###性能和速度###

另一个对于软件架构和抽象的常见批判是针对性能方面的——尤其是在游戏圈。许多设计模式通过虚函数调用，接口，指针，消息或者其他有一定运行时开销的手段，达到使架构更灵活的目的。

_其中有一个讽刺的范例，就是 C++ 中的模板。C++ 中的模板元编程可以在零运行时开销的前提下，实现一些抽象接口的概念。_

_这是一个灵活性的权衡问题：如果你在一个类中调用具体函数，那么它便被编译时固化了。但是如果你通过虚函数/接口调用，那么具体的调用对象只有在运行时才知道。这种形式更灵活，但是也引入了一些额外的运行时开销。_

_模板元编程很有趣。它的调用对象是在编译时，模板特化所决定的。这很吓人的你说多吓人。_

这是有原因的。许多软件架构是为了让你的软件更加灵活的，也就是说更容易改变，意味着加入更少的假设。你可以使用接口，所以你的代码可以在任意的类上跑起来（而不是现在仅有的一个类），你可以使用观察者/消息模式实现游戏中两部分之间的交互。这样以后就可以加入第三个，第四个部分。

但是性能是依赖于假设的。许多优化依赖于具体的限制。比如我们可以假设敌人不会超过过 256 个，这样我们可以仅仅用一个 byte 来作为编号。我们可以假设只会调用一个具体类型的某个函数，那么我们就直接静态调用甚至于将其内联。我们可以假设所有的物件都是同一个类型，那么我们可以直接使用一个连续数组来存储。

这些不意味着灵活性不重要。一定的灵活性能让我们快速地修改游戏，获得更高的开发效率和开发体验。毕竟没人能一次性设计出平衡的游戏，好游戏需要若干的迭代和测试。

而灵活性让人们能更容易的实践自己的想法，也更容易发现优秀的设计。更好地调整游戏。

对于这个问题，没有完全的答案，程序变得更灵活，那么原型设计会更容易，但是会带来一些性能损失。对代码的优化又会降低灵活性。

而就我的经验而言，把一个好玩的游戏做的流畅，相比把一个流畅的游戏做的好玩更容易。所以我们做了一个妥协，保持代码的灵活，直到设计确定下来。然后去除一些抽象，提高性能。

###劣质代码中的好###

下一个问题，不同的代码风格该在何时何地使用。许多这方面的书都是关于编写干净整洁易维护的代码的，我也支持按照应有的方式来编写代码。但是这不意味着不工整的代码就没有价值。

编写结构良好的代码需要大量的思考——也就是时间，而维护好的结构则需要更多的精力。很多时候你需要在同一套代码的基础上，工作很长的时间。然而同样的，游戏设计需要很多实验和探索，尤其是在开始的时候，编写自己很明确地直到以后会废弃的代码，不是什么稀有的情况。

如果你只想知道一个想法行不行/好不好，那么过度的雕琢意味着得到结果会很慢——更别提完成之后无法被采用的状况了，这种情况下，雕琢 = 浪费时间。

原型设计，也就是以实践的方式回答设计问题，是    //    TODO

###尝试寻找一个平衡###

一般来说在实际开发中，我们有三个目标：

1. 为了工程的长期健康运作，好的架构十分必要。
2. 游戏运行性能要好。
3. 现在需要做的功能需要赶快做出来。

_讽刺的是这三样都是关于速度的：长期开发速度，执行速度和短期开发速度。_

这三样东西之间是有一些小矛盾的。

好的架构会提高长期的生产力，但是为了维护它，也会付出更多的精力。

写起来最快最容易的代码往往不是运行最快的。优化是十分耗时的过程。而优化也会打乱原本清晰的架构。

而如果你急着完成今天的任务，赶工出来的代码质量也不会太高。

这个问题困扰了很多人，尤其是新手。实际上没有正确答案，只有不同形式的错误答案。

但是对于我来说这是一个十分有意思的问题，实际上每一个领域都有类似的问题，如果它们都有答案的话，那也就意味着谁都能去做。只能满足你一周胃口的领域是很无聊的。

对于我来说，这个和游戏本身也有很多共同点。类似棋类的游戏，很难精通，因为整个游戏是完美平衡的，你一辈子都找不到可能性的尽头。而一个设计低劣的游戏，其结果很容易倾向于某种策略，最后让人感到很无聊并退出游戏怒删之。

###极简###

后来我找到了缓解这个问题的手段——极简主义。现在我会花很大的功夫，试图编写最干净直接的解决方案——当你读完之后便完全能理解并且想不出其他方案的代码。

首先是保持数据结构和算法的简单与准确，之后延伸到其他的元素，最后你会发现整体的代码更少了，也就是说在修改之前需要理解的代码也更少了。

这种代码也更快，因为很少有额外开销，本身代码量也更小。

注意，我并没有说简单的代码更容易编写。好的解决方案可以不是增加代码，而是精炼代码。

很多时候我们面对的不是一个简单的问题，而是一打实际情况。你需要在 Z 条件时让 X 对象执行 Y 动作，让 W 对象执行 A 动作，blablabla

最简单直接的解决方案是将这些一次性编写出来，对于新手程序猿就是大量的判断逻辑。

但是这不够优雅，而这种风格在情况稍微改变时便会难以适应。而一个更加优雅的解决方案，需要具备的基本要素之一就是通用性——包含了大量情况的小逻辑。

找到这个方案并不简单，它需要分析实例来找出其下隐藏的信息，但是当找出之后，世界会变得非常美好。

######

几乎所有人都会跳过导引部分，所以我佩服你能坚持到这里。很可惜我没有钱能给你，但是我能给你一点鸡汤：

* 抽象和解构能让你的迭代过程更快更简单，但是在你不确认代码需要灵活性的时候不要滥用。

* 在开发过程中，考虑性能问题，为性能留出设计空间，但是不要在一开始的时候就考虑引入假设的底层优化。

* 应该更多地探索你游戏的设计空间，但是不要走得太远。


* 不要浪费时间在美化不必要的代码上。


* 最重要的是，如果你想做有趣的东西，那么做的过程也应该是有趣的。
