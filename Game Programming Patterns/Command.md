##命令模式##
---
####游戏编程模式 - 重温 设计模式####

命令模式是我最喜欢的模式之一。我开发的任何一个较大型的程序，无论是不是游戏，都会在某些地方用到它。用好的话，这个模式能起到很好的解构的作用。由于其本身的复杂性，在原书中，对于这个模式的解释是有一些复杂的：

> 把请求作为一个对象来封装，让用户使用请求来操作客户端，如查询，记录。支持可撤销的操作。

我觉得任何人都不会认为这是一个容易理解的定义。这句话似乎故意隐藏了它所要表达的意思，如果不用软件圈子里的奇怪语言逻辑来解释的话，其中的“客户”是指一个人——而人是不能“操作”的。

后面的仅仅是列举出这个模式可能的一些用处而已，如果你没有碰到这些情况就完全没用了。所以在这里我重新给命令模式下一个定义：

#####一个命令就是一个具体的方法调用。#####

_某些语言中的“反射系统”提供了运行时操作类型信息的能力，允许获取代表其他对象类型的对象。实际上，反射便是一种具体化的类型系统。_

它将_概念_变为_数据_ - 也即一个可以用来存储/传参的对象。所以具体说来，命令模式是一种“具体的方法调用”，就是指一个包装在对象中的方法调用。

这个你第一反应往往是“回调函数”，“头等公民函数”，“函数指针”，“闭包”之类的东西——不同的语言有不同的手段。

实际上就是这样的，原书中提到了：

> 命令就是回调函数的面向对象形式。

实际上这句话可能相对于开头的那个定义好太多。

不过上面说的都太抽象笼统了，我们需要一些具体的东西。下面我们将通过例子探讨命令模式适合的情况。

###输入的配置###

几乎每个游戏中都需要有一些处理用户输入的代码，比如按钮的点击，键盘操作，鼠标事件等等。这些代码的任务就是接受输入，并且根据输入调用对应的函数来执行操作。

比如：

* 按下 X 键 调用 Jump() 函数
* 按下 Y 键 调用 Fire_Gun() 函数
* 按下 A 键 调用 Swap_Weapon() 函数
* 按下 B 键 调用 Lurch() 函数

我们会很自然的写出一个简单的实现：

    void InputHandler::handleInput() {
        if (isPressed(BUTTON_X)) Jump();
        else if (isPressed(BUTTON_Y)) fireGun();
        else if (isPressed(BUTTON_A)) swapWeapon();
        else if (isPressed(BUTTON_B)) lurchIneffectively();
    }

这个函数很容易看懂，一般是在___游戏循环___中每一帧调用一次。如果我们要把用户的特定输入与特定的游戏操作绑定的话，这样写可以，但是一般游戏都会让用户自定义操作的意义。

这样我们就需要把游戏操作函数的调用变成一些能够改变的东西。而“能够改变的东西”很自然地联想到变量，所以我们需要能够代表游戏动作的_对象_。

对于能够触发的游戏动作，我们定义一个基类：

    class Command {
        public:
            virtual ~Command();
            virtual void execute() = 0;
    };
    
_命令模式很适合用在只拥有一个无返回值方法的接口上。_

之后对于不同的游戏动作，我们创建若干个基类：

    class JumpCommand : public Command {
        public:
            virtual void execute() { Jump(); } 
    };
    
    class FireCommand : public Command {
        public:
            virtual void execute() { Fire_Gun(); }
    };
    
    //    blablabla
    
在输入处理器（Input Handler）中，我们为每个输入定义一系列指向命令的指针：

    class InputHandler {
        public:
            void handleInput();
            
            //    Methods to bind commands...
            
        private:
           Command *buttonX_;
           Command *buttonY_;
           Command *buttonA_;
           Command *buttonB_;
    };

然后在处理输入时就只需要：

    void InputHandler::handleInput() {
        if (isPressed(BUTTON_X)) buttonX_->execute();
        else if (isPressed(BUTTON_Y)) buttonY_->execute();
        else if (isPressed(BUTTON_A)) buttonA_->execute();
        else if (isPressed(BUTTON_B)) buttonB_->execute();
    }
    
_你或许已经注意到了，我们并没有处理 nullptr 的情况。实际上在这里我们假设每一个命令都已经存在对应的保定。_

_但是对于一些不需要的键（不执行任何操作），为了保持程序的整齐，在处理输入时逐个检查指针是否为空并不十分合适。我们可以定义一个 execute() 方法为空的类，之后将其绑定到对应的键上。这其实是一种叫做___空对象___的模式的应用。_

这就是命令模式的大致含义，我想你应该已经理解了它的意义。

###角色的方向###

我们刚才定义的命令基础类十分适合上一个例子，但是它的功能很受限。能够使用这种方案的前提是，程序定义了顶级的类似 Jump(), Fire_Gun() 之类的接口。而这类接口本身是不明确的。

这就限制了上文中命令类的通用性。我们试图放宽这一限制，不直接调用顶层接口，而是将待操作的对象传给相应的函数。

    class Command {
        public:
            virtual ~Command() { }
            virtual void execute(GameActor& actor) = 0;
    };
    
在这段代码中，GameActor 是我们用来描述游戏对象的类，我们将它的实例传给 execute() 方法，这样就能够将某一个命令应用到任何的角色上，例如：

    class JumpCommand : public Command {
        public:
            virtual void execute(GameActor& actor) { actor.jump(); }
    };
    
现在我们就可以利用这个类让任何一个角色跳起来了。但是我们忘记了一个部分，在输入处理器和命令之间的调用，我们需要给命令指定对应的对象。

首先，我们修改 handleInput() 函数，让它返回一个命令对象。它的作用仅仅是选择命令，而不是执行命令。

    Command *InputHandler::handleInput() {
        if (isPressed(BUTTON_X)) return buttonX_;
        else if (isPressed(BUTTON_Y)) return buttonY_;
        else if (isPressed(BUTTON_A)) return buttonA_;
        else if (isPressed(BUTTON_B)) return buttonB_;
        
        return NULL;
    }
    
命令是具体化的函数调用——这样做不仅能让我们选择执行命令的对象，还能延迟命令的执行。

    Command *command = inputHandler.handleInput();
    if (command) command->execute(actor);
    
假定 actor 是玩家角色的引用，代码执行将会产生和上一个例子相同的结果

实际上，这不是一个十分常见的功能。但是我们经常需要面对另外一个问题：我们到现在一直在考虑由玩家控制的角色，但是在游戏世界中不只有玩家控制的角色，还有由游戏人工智能控制的对象。我们可以利用已经封装好的命令接口来连接 AI 引擎和角色，AI 部分的代码只需要操作命令即可。

这样我们便实现了 AI 和角色的解构，并且获得了更多的灵活性。我们可以在不同的角色上使用不同的 AI 逻辑，或者混合不同的 AI 行为。甚至为玩家的角色添加傀儡系统（Dummy System）。

通过命令的封装，我们解除了直接的方法调用增加的耦合性，而以一个类似命令队列/命令流的形式取而代之。游戏系统中的某些模块（例如输入处理器和 AI）下达命令并放入队列（生产者），零一些模块（命令分派器或角色本身）执行命令（消费者）。通过引入命令队列作为中间件来实现两者之间的解构。

___事件队列模式__中包含若干其他队列的应用。_
    
_如果我们将命令储存下来，并且序列化。就可以将它们通过网络发送到其他的机器上并回放，这是制作网络多人游戏的关键。_

###撤销与重做###

这是命令模式最著名的应用之一。如果一个命令执行的操作比较小，那么就有可能进行撤销。这种设计在一些战略游戏中很常见，允许玩家回滚自己的操作。同时，在制作游戏的时候，这个功能也是一个必备品。如果你想恶心游戏开发者的话，只要不要给地图编辑器加入撤销功能就足够了。

命令模式是实现撤销功能最简单的一种方式。假设我们制作的是一个单人回合制的游戏，加入撤销功能可以让玩家更多地关注战略，而非猜测。

我们已经使用了命令模式来抽象输入处理过程，所以每一个操作都是被封装好的。比如单位的移动应该是这样的：

    class MoveUnitCommand : public Command {
        public:
           MoveUnitCommand(Unit * unit, int x, int y) : unit_(unit), x_(x), y_(y) { }
           
           virtual void execute() { unit_->moveTo(x_, y_); }
           
        private:
            Unit *unit_;
            int x_, y_;
    };
    
注意这个例子和我们之前的命令有所不同，在上一个部分中，我们希望能把命令和角色之间分开，而在这里，我们把命令和角色绑定在一起了。执行这个命令的实例并不代表根据上下文“移动某个对象”，而是移动某一个具体的对象。

这一现象也体现出了命令模式实现的多样性。在我们的第一类例子中，一个命令对象是可重用的，代表一个动作，当按下特定的键时，输入处理器选择一个命令对象，直接调用它的 execute() 方法。

而在下面的例子里，命令变得更为明确了。它们代表的是在特定的点执行的特定动作：

    Command *handleiInput() {
        Unit *unit = getSelectedUnit();
        
        if (isPressed(BUTTON_UP)) {
            int destY = unit->y() - 1;
            return new MoveUnitCommand(unit, unit->x(), destY);
        }
        
        if (isPressed(BUTTON_DOWN)) {
            int destY = unit->y() + 1;
            return new MoveUnitCommand(unit, unit->x(), destY);
        }
        
        //    other moves...
        
        return nullptr;
    }
    
_当然，这么做也必然使得输入处理器必须在每次用户操作时都创建一个新的命令实例。在 C++ 这种缺少垃圾回收机制的平台中，就意味着你必须注意处理内存释放问题。_

在这种实现中，每个命令都是一次性的。看起来不合适，但是俗言塞翁失马，这一点对于实现撤销功能来说是关键的。

我们为命令类的接口额外添加一个操作：

    class Command {
        public:
            virtual ~Command() { }
            virtual void execute() = 0;
            virtual void undo() = 0;
    };

undo() 方法对游戏状态的改变执行逆向操作：

    class MoveUnitCommand : public Command {
        public:
            MoveUnitCommand(Unit *unit, int x, int y) : unit_(unit), xBefore_(0), yBefore_(0), x_(x), y_(y) { }
            
            virtual void execute() {
                xBefore_ = unit_->x(), yBefore_ = unit_->y();
                
                unit_->moveTo(x_, y_);
            }
            
             virtual void undo() { unit_->moveTo(xBefore_, yBefore_); }
             
         private:
             Unit *unit_;
             int xBefore_, yBefore_;
             int x_, y_;
    }
    
可以发现我们增加了一些状态。在之前的情况中，单位移动了之后会忘记它原来的位置。而如果要撤销该操作，我们需要使用 xBefore\_ 和 yBefore\_ 两个变量来记忆。

_这种做法很像___备忘录模式___，但是我不认为备忘录模式适合这种情况。一个命令往往只会修改对象的少数状态，完全记忆整个对象的状态是一种浪费，反而不如手动处理记忆被修改的状态。_

____持久性数据结构___也可以用来实现这个功能。即，对于某一对象的任何修改都将返回一个新的对象，旧的对象依然保留。这种方式表面上看代价很大，但是如果实现足够巧妙（新对象和旧对象共享存储空间），将会节省大量的运行时间。_

_在应用了持久性数据结构的前提下，让每一个命令存储执行命令之前对象的引用，那么撤销操作只需要切换会原来那一个对象即可。_

对于多次撤销的支持也不难。维护一个命令的列表，并增加一个指针，指向上一条命令。当用户执行一个命令时，就把它插入到列表中，并把当前命令的指针指向它。当用户撤销命令时，就对当前命令执行撤销，并且把指针向后移动。当用户重做时，就把指针向前移动，并且执行该命令。如果用户在撤销若干步之后执行了新的命令，就把当前指针后面的命令全部抛弃。

我第一次实现这类功能，是在一个地形编辑器里面。我为它的直接与流畅感到惊奇。当然你需要确认每一条指令对于状态的修改，但是完成了之后，结果是十分激动的。

_在游戏中，重做功能非常少见，但是__回放__功能很多。实现回放，比较naive的做法就是把每一帧的状态逐个记录下来，但是这样做的空间成本太大了。_

_许多游戏的做法是，记录每一帧每个对象执行的命令。在回放时按照正常模拟过程运行，执行录制的命令序列。_

###两大潮流的碰撞###

我在本节的一开始说命令是类似一等公民函数或闭包之类的东西，但是我后来给出的每个例子都使用了类定义。如果你比较熟悉函数式编程，可能会产生“函数在哪呢”这样的疑问。

我使用这样的实现方式，主要还是因为 C++ 本身的限制。C++ 对一等公民函数的支持比较有限，需要指出的是，函数指针是没有状态的，函数对象显得非常怪异——何况函数对象本身就是类，C++ 11 中的 lambda 函数在处理内存管理问题上较为麻烦。

这并不意味着你在其他语言中也必须这么做，如果你使用的语言有真正的闭包功能，那就应该直接使用——其实命令模式在某种程度上就是为了弥补传统语言没有闭包功能的缺陷的。

_上面的定义并不肯定，在语言支持闭包的前提下，有时依然有必要为命令建立类结构。比如，当一个命令有多个操作时，将它们全部挤到一个函数里就不太合适了。_

_定义真实的类也可以使命令包含的数据更为清晰。闭包是一种简单自动的数据封装方式，但是也可能会造成一些混乱。_

比如，如果你在用 JavaScript 制作一个游戏，那么就可以使用以下的代码来实现移动：

    function makeMoveUnitCommand(unit, x, y) {
        return function () { unit.moveTo(x, y); }
    }

多个闭包可以用来实现撤销：

    function makeMoveUnitCommand(unit, x, y) {
        var xBefore, yBefore;
        return {
            execute: function() {
                xBefore = unit.x();
                yBefore = unit.y()
                unti.moveTo(x, y);
            },
            undo: function() {
                unit.moveTo(xBefore, yBefore);
            }
        };
    }
    
如果函数式的风格对于你更顺手，这么做也很好，或者就算你不习惯这么做，我也希望这一部分能给你一些启发。至少对于我来说，命令模式的实用已经让我明白了函数范式在处理许多问题时的高效。

###其他###

* 采用这种模式，到最后你可能会写出一大堆命令类。为了简化这个实现过程，你可以定义一个拥有一些便于调用的高级方法的具体基类，这样派生的命令可以利用组合的形式来定义行为。这实际上是一种___子类沙盒模式___的应用。

* 在上文举出的例子中，我们明确的指定了接受命令的对象。但是在某些情况下（尤其是当你使用分层对象模型的时候），可能不是这么直接。目标对象可能会直接对命令做出反应，或者向下传递给子对象，这是___责任链模式___的应用。

* 对于某些比较简单的，不需要状态的行为（类似于跳），产生多个实例是对内存空间的浪费，此时可以使用___享元模式___。