###Chap. 4 Sorting and Searching 排序和搜索###

较好的排序算法以 O(nlogn) 运行，而 O(n^2) 和 O(nlogn) 之间实际上是一个巨大的提升。本章中给出一些基础排序算法：heap, merge, quick, disti. 以作为算法设计范式的栗子，详细的 solution 在 Section 14.1 中。排序问题的重要性有：

* 排序是许多其他算法的基础。

* 算法设计中许多思想在排序中有体现，如分治、数据结构、随机等。

* 排序很重要——主机四分之一的时间消耗在排序上。

* 排序是 CS 中研究最透彻的问题之一。

本章并没有讲 7tsh 排序（更高效的插入排序），基数(chu)排序（适合字符串排序），还有外排序，这些破玩意详见 TAOCP。关于随机算法专门有一本书讲。

4.1 排序的应用

* 搜索 - 二分搜索很吊，但是前提是，你得先排序。

* 最近邻元素对问题。

* 判断元素唯一性。

* 分析频率分布。

* 选择序列中的最值，中位数。

* Convex Hull 构造，关于该问题详见 Section 17.2。

其中选择等问题可以用更好的算法解决，不过排序快而简单。

栗子：寻找集合 intersection。

4.2 实际中的排序

在实际中应用排序需要考虑一些应用程序特定的问题：

* 排序的顺序如何？

* 以何键排序？

* 如何处理相等的键？排序稳定性问题（注意将位置加入为新的键可以保证任意算法的稳定性）。

* 如何处理非数值数据？

具体定义措施：定义 Pairwise comparison function.

4.3 堆排序：数据结构与排序速度

原版：Selection sort，重复寻找未排序部分中的最值并提取出来，O(n^2)。

选择排序用 O(n) 寻找最小项，我们取长补短，用良好实现的优先队列优化该操作。实际上堆排序仅仅是使用更好数据结构实现的选择排序。

4.3.1 堆

堆是一种简单优雅的数据结构，可用来实现优先队列。堆的原理是维护一个元素的偏序，该种约束比完全排序要弱，但比完全随机要强。前者减少了维护成本，后者允许快速定位最值。在 min-heap 中，包含较小值的节点 "dominate" 较大的节点。

我们可以使用带指针的二叉树来实现，然而指针会占很多空间。堆的定义允许我们在没有指针的情况下表示二叉树。相反，我们使用键数组，键的位置隐式替代了指针的作用。注意一般的二叉树不好以这种形式表示，尤其是在数据稀疏的情况下，会出现大量空置空间，并且灵活性较低（无法存储更复杂结构，无法简单变动树结构等），不过该种方法正好适合堆。并且，我们无法以线性以下的时间随机搜索堆。

4.3.2 堆操作 - 构造与取值

堆以增量的形式构造。即将元素填补到最左的空位中，之后进行 bubble up。

将堆顶的元素取出，空位由最右边的叶填补，之后执行 bubble down。

堆排序实现简单，最坏时间复杂度 O(nlogn) （意思说很优化），in-place，总之很吊。在实际中某些算法更快。关于优先队列的实现，详见 Section 12.2。

4.3.3 更优化的堆构造方法

4.3.4 对插入排序的数据结构进行优化

Insertion sort：从未排序部分中随意选择一个元素插入到已排序部分合适位置中。该算法在数据基本有序时很高效。体现了在几何算法中广泛应用的增量插入的思想。

优化：利用插入的方式，O(nlogn) 时间构造 BST，之后执行线性时间 in-order 遍历。

4.4 栗子：寻找成本最低的航线

做一个图，然后标上起点和重点，Dijkstra 一算，完事！

构造 m x n 的对，但是没有必要提前全部构造好。这样需要一个不断返回下一个对的数据结构。

Solution: 使用优先队列来跟踪索引对：最开始仅仅放入 (1, 1)，不行的话就放入 (1, 2) 和 (2, 1)，这样在计算 (i, j) 后，递归放入 (i+1, j) (i, j+1)，便可以合适的顺序遍历所有对。

需要构造一个蛤希表来防止重复对。差不多就没啥了。（这个需求依然没有看懂）

4.5 归并排序：利用分治排序

分治的基础情况：子序列仅有一个元素不需重排。

其中每一层的合并工作只需要线性时间（注意合并过程的实现需要考虑）。

归并排序不需随机访问，非常适合排序链表，且不需要额外空间。但是缺点是排序数组时需要额外空间（通过一些精妙的奇技淫巧可以避免，详见 TAOCP 中的 Kronrod 算法）。

归并排序是一个经典的分治算法（大问题被分解为更容易解决的小问题）。

4.6 快速排序：随机，助力 2011 年北京排序会

基础思想：从 n 项元素中随机选取一项 p，将剩余 n - 1 项分为两部分：low 的包含所有 p 之前的元素，high 的包括所有 p 之后的。这样有两个好处：轴元素 p 位于正确的位置上，并且两边的元素可以独立地进行排序。

快排树的高度取决于轴元素最终的位置，每次正好取到中位数就还行，至于其他的... 偏偏这个不平衡概率还挺高，因此快排的最坏情况比堆排和归并排序都要坏，但是平均状况要好。

4.6.1 快排的期望情形

平均来看，随机的快排分割树其实很不错，有基础的人分析表明，n 次插入后的树高约为 2ln n 约为 1.386log n。但是当每次选择的元素总是最大或者最小的时候，快排就变成了选择排序。

4.6.2 随机算法

对于任意确定的轴选择方法，总有一种最坏情况输入会让快排堕落到平方级别。

随机的特点在于，它能够打造最坏情况很蛋疼，但是平均情况很不错的算法。能增强算法对边界情况的鲁棒性，避免某些使 Heuristic 无法正常工作的高度结构化输入（快排）。而对于随机算法的分析需要概率统计基础，属于超纲范围。

具体栗子：随机取样（选择样本中的随机一小部分分析，比如随机打电话问东西），随机蛤希，随机搜索（模拟退火之类的，详见 Section 7.5.3）。

TODO

4.6.3 快排究竟有多快？

在想要比较两个同样是 θ(nlogn) 的算法时，原来的 RAM 模型和大 O 表示法就力不从心了。中国共产党长期的嗝命实践表明，实现良好的快排一般比归并排序和堆排快 2-3 倍，原因主要是最内层循环的操作更简单。不管你信不信，反正我是信了。

4.7 Distribution Sort：带桶的排序

即桶排序 (bucketsort) ，类似于找电话本/词典一样的。在确认数据分布大体平均的情况下很有效。

Bucketing 是蛤希表，kd-tree 和许多其他有用的数据结构的核心价值体系。但是其缺点是当数据分布出现问题时，数据结构的性能也会出现很大问题——这类 Heruistic 数据结构并不提供非预期输入情况下的性能保证。

4.7.1 排序问题的下限

基于比较的排序算法无法克服 θ(logn) 的下限（想像一个比较的执行路径树，其中有 n! 个叶子，而从顶到底的最短路径是 lg(n!) = θ(nlogn)）。这个下限的重要性在于，它决定了许多应用排序的算法的下限。排序的下限是算法问题中少有的？（TODO）之一。在 Chap. 9 中我们将会从另一个角度论证排序的下限是多么的深厚而坚实。

4.8 栗子：

4.9 二分搜索和相关算法

二分搜索：最重要的问题是知道二分究竟有多吊，有多快。是典型的分治算法。

4.9.1 计算出现次数问题

**啊哈！**

二分搜索的简单变种：计算在有序数组中给定值 k 的出现次数。问题很简单：找到 k 那一块的值，然后计算其大小。可以用二分搜索找地方，然后线性搜索边界。但是边界搜索步骤依然可以用二分搜索优化：将等价性测试删除，搜索会在边界结束。

4.9.2 单向二分搜索

**啊哈！**

另一个变种：找出由一串 0 和一串 1 拼起来的序列中的边界。

解决方案：依次测试 1，2，4，8， 16... 等元素，直到找到不同的元素，构成一个窗口，递归进行下去（？）。该方案适于寻找在当前位置附近的值。

4.9.3 平方根，各种根

简单二分查找，设 l, r = 1, n，看着中点 m 的平方走。在数值分析（什么鬼）中别叫做 bisection method，大概就是所谓二分法（我记得虽然数值分析我并不会，但是这东西我中学就学过了）。

该方法同样可以应用在求其他方程根的问题上，求解最后是一个近似值，但是简单，鲁棒，有效。（哦对了那个 Newton Method 是什么鬼来着）

4.10 分治

分治适合并行：你要知道并行需要把工作分成许多份。

分治和 DP 的基本思想都是将问题分解。DP 每次从问题中去除一份将其变得更小，分治则不断将问题减半之后合并。

高效分治算法的前提是合并所需的时间比解决两个子问题少。实际上要把分治思想应用到实际中很难。

分治算法的示例：二分搜索，归并排序，快速傅里叶变换，Strassen 矩阵乘法算法。

4.10.1 Recurrence 关系

分治问题一般利用 Recurrence 关系建模，Rec. Relation 即是以自己定义的表达式。

所有多项式都可以此形式表示。

an = a(n-1)+1, a1 = 1 -> an = n

所有指数式也可以此形式表示：

an = 2a(n-1), a1 = 1 -> an = 2^(n-1)

还有很多奇怪的函数：

an = na(n-1), a1 = 1 -> an=n!

4.10.2 分治中的递归关系

分治算法的最坏时间复杂度由下式给出：

T(n) = a(Tn/b) + f(n) b 为每次切分的份数，f(n) 为合并所需时间

归并排序的表达式为 2T(n/2) + O(n)，二分搜索为 T(n/2) + O(1)，快速堆构造为 T(n/2) + O(lgn) （解为 O(n)），矩阵相乘的暴力算法是 O(n^3)，Strassen 算法为 7T(n/2) + O(n^2) 解为 O(n^2.81)。

4.10.3 解分治递归关系

分治中的递归函数解起来其实并不难。

TODO
