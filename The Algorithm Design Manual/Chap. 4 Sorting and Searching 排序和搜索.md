###Chap. 4 Sorting and Searching 排序和搜索###

较好的排序算法以 O(nlogn) 运行，而 O(n^2) 和 O(nlogn) 之间实际上是一个巨大的提升。本章中给出一些基础排序算法：heap, merge, quick, disti. 以作为算法设计范式的栗子，详细的 solution 在 Section 14.1 中。排序问题的重要性有：

* 排序是许多其他算法的基础。

* 算法设计中许多思想在排序中有体现，如分治、数据结构、随机等。

* 排序很重要——主机四分之一的时间消耗在排序上。

* 排序是 CS 中研究最透彻的问题之一。

4.1 排序的应用

* 搜索 - 二分搜索很吊，但是前提是，你得先排序。

* 最近邻元素对问题。

* 判断元素唯一性。

* 分析频率分布。

* 选择序列中的最值，中位数。

* Convex Hull 构造，关于该问题详见 Section 17.2。

其中选择等问题可以用更好的算法解决，不过排序快而简单。

栗子：寻找集合 intersection。

4.2 实际中的排序

在实际中应用排序需要考虑一些应用程序特定的问题：

* 排序的顺序如何？

* 以何键排序？

* 如何处理相等的键？排序稳定性问题（注意将位置加入为新的键可以保证任意算法的稳定性）。

* 如何处理非数值数据？

具体定义措施：定义 Pairwise comparison function.

4.3 堆排序：数据结构与排序速度

原版：Selection sort，重复寻找未排序部分中的最值并提取出来，O(n^2)。

选择排序用 O(n) 寻找最小项，我们取长补短，用良好实现的优先队列优化该操作。实际上堆排序仅仅是使用更好数据结构实现的选择排序。

4.3.1 堆

堆是一种简单优雅的数据结构，可用来实现优先队列。堆的原理是维护一个元素的偏序，该种约束比完全排序要弱，但比完全随机要强。前者减少了维护成本，后者允许快速定位最值。在 min-heap 中，包含较小值的节点 "dominate" 较大的节点。

我们可以使用带指针的二叉树来实现，然而指针会占很多空间。堆的定义允许我们在没有指针的情况下表示二叉树。相反，我们使用键数组，键的位置隐式替代了指针的作用。注意一般的二叉树不好以这种形式表示，尤其是在数据稀疏的情况下，会出现大量空置空间，并且灵活性较低（无法存储更复杂结构，无法简单变动树结构等），不过该种方法正好适合堆。并且，我们无法以线性以下的时间随机搜索堆。

4.3.2 堆操作 - 构造与取值

堆以增量的形式构造。即将元素填补到最左的空位中，之后进行 bubble up。

将堆顶的元素取出，空位由最右边的叶填补，之后执行 bubble down。

堆排序实现简单，最坏时间复杂度 O(nlogn) （意思说很优化），in-place，总之很吊。在实际中某些算法更快。关于优先队列的实现，详见 Section 12.2。

4.3.3 更优化的堆构造方法

4.3.4 对插入排序的数据结构进行优化

Insertion sort：从未排序部分中随意选择一个元素插入到已排序部分合适位置中。该算法在数据基本有序时很高效。体现了在几何算法中广泛应用的增量插入的思想。

优化：利用插入的方式，O(nlogn) 时间构造 BST，之后执行线性时间 in-order 遍历。

4.4 栗子：寻找成本最低的航线

做一个图，然后标上起点和重点，Dijkstra 一算，完事！

构造 m x n 的对，但是没有必要提前全部构造好。这样需要一个不断返回下一个对的数据结构。

Solution: 使用优先队列来跟踪索引对：最开始仅仅放入 (1, 1)，不行的话就放入 (1, 2) 和 (2, 1)，这样在计算 (i, j) 后，递归放入 (i+1, j) (i, j+1)，便可以合适的顺序遍历所有对。

需要构造一个蛤希表来防止重复对。差不多就没啥了。（这个需求依然没有看懂）

4.5 归并排序：利用分治排序

分治的基础情况：子序列仅有一个元素不需重排。

其中每一层的合并工作只需要线性时间（注意合并过程的实现需要考虑）。

归并排序不需随机访问，非常适合排序链表，且不需要额外空间。但是缺点是排序数组时需要额外空间（通过一些精妙的奇技淫巧可以避免）。

归并排序是一个经典的分治算法（大问题被分解为更容易解决的小问题）。

4.6 快速排序：随机，助力 2011 年北京排序会

4.6.1

4.6.2 随机算法

4.6.3 快排究竟有多快？

4.7 Distribution Sort：带桶的排序

即桶排序 (bucketsort) ，类似于找电话本/词典一样的。在确认数据分布大体平均的情况下很有效。

Bucketing 是蛤希表，kd-tree 和许多其他有用的数据结构的核心价值体系。但是其缺点是当数据分布出现问题时，数据结构的性能也会出现很大问题——这类 Heruistic 数据结构并不提供非预期输入情况下的性能保证。

4.7.1 排序问题的下限

基于比较的排序算法无法克服 θ(logn) 的下限（想像一个比较的执行路径树，其中有 n! 个叶子，而从顶到底的最短路径是 lg(n!) = θ(nlogn)）。这个下限的重要性在于，它决定了许多应用排序的算法的下限。排序的下限是算法问题中少有的？（TODO）之一。在 Chap. 9 中我们将会从另一个角度论证排序的下限是多么的深厚而坚实。

4.8 栗子：

4.9 二分搜索和相关算法

4.9.2 单向二分搜索

4.10 分治