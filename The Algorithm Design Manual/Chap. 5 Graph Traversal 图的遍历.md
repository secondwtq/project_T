###Chap. 5 Graph Traversal 图的遍历###

图在 CS 中很重要，交通、人际关系、网络等等许多东西，只要图一种数据结构都可以解决。图几乎可以表示任何关系。

高效使用图算法的关键在于正确建模问题。熟悉更多图的算法问题比理解特定图算法的细节更重要（何况第二本书给你提供了实现，但是前提是你知道问题的名字）。本章描述图的基本结构和遍历操作，Chap. 6 会涉及最小生成树等高级图算法。

5.1 图的口味

一个图 G = (V, E) 定义为点的集合 V 和一个 V 中（有序或者无序）的点对边的集合 E。图的基础属性有如下几个，这些属性允许我们用图抽象、分析并表达对实际问题的建模：

* 有向/无向。对于 (x, y) ∈ E，(y, x) ∈ E，则说图是无向的。

* 带权/无权。对于最短路径问题，无权图是找边数最少的路径，可以使用 BFS 完成，带权图则需要使用 Chap. 6 中描述的更加复杂的算法。

* 简单/复杂。某些类型的边会使图的处理更加复杂，比如只涉及一个点的 self-loop (x, x)，或者在图中出现多次的 multiedge。不存在这类结构的图叫做简单图。

* 稀疏/密集。当只有少数点对属于边的时候图是稀疏的，其标准并没有明确的规定，但是稀疏图的边数一般是线性的，密集图一般是平方级别的。

* Cyclic/Acyclic。不包含任何循环的图称为 acyclic 图。例如树是连接、无循环的无向图。DAG - Directed acyclic graph，经常出现于规划问题。许多 DAG 算法的第一步一般是拓扑排序。

* Embedded/Topological。以几何位置定义点的图称其为 embedded，一般来说这种图的边由其依赖的图形隐式定义。

* 显式/隐式。某些图的应用并非是显式构造一个图之后遍历，而是在使用的时候隐式建立，例如 backtrack 搜索，这种情况下可能会方便一些，因为并不需要存储全部图。

* 有标签/无标签。有标签图中，每一个点都有一个唯一的名称/标识符。标签可以用来解决图的等价性问题（使用 backtracking，给两个图中的点标记 label）。

5.1.1 朋友关系图

人们的许多有趣的方面和行为以关系图的属性体现出来。关系图是稀疏的，同时其中存在若干个问题：如果我是你的朋友，是否意味着你也是我的朋友？两个朋友之间有多近？我是我自己的朋友么？朋友之间的地理关系怎样？“朋友的朋友”是一种什么关系？etc.

PS：在朋友关系图和疾病传染图等应用中，标签很多时候并不重要，人们仅仅是一个序号，当然你会说我是一个名字，不是序号——跟做算法的人撕去吧。

5.2 图的数据结构

这个问题上有两个选择：邻接表和邻接矩阵，选择正确的数据结构对性能很重要。邻接矩阵可以高效解决某一条特定边是否在图里的问题，支持高效的增删边操作，但是对于稀疏图空间效率不高（有一些奇技淫巧但是牺牲了简单性）。邻接表需要有指针，并不能快速判断两点间是否有一条边，但是可以在设计算法时避免这种问题。

大多数情况下我们使用邻接表。

在数据结构的具体设计上，我们在图中存储总顶点数，用顶点 ID 表示顶点，使用链表数组存储边。对于 insert_edge 函数，我们把新的边插入到链表头部。关键问题是方向性，我们加入了一个 bool directed 参数，在为 false 时会对反方向递归调用一次本函数。

对于通用图数据结构的具体实现，我们推荐 LEDA 和 Boost，分别在 Section 19.1.1 和 Section  19.1.3 中描述。它们强大，有点笨重（慢），然后定制性不是很好。

5.3 栗子：我是摩尔定律的受害者

I wrote Combinatorica.

Pardon? whaaat?

www.combinatorica.com，一个 Mathematica 下的图算法库。由于其运算模型和解释开销的原因，Mathematica 的效率是个问题，比如比 C 代码慢几千倍，甚至不支持数组的常数写操作，并且吃内存，1990 年我写这个库的时候得要 4MB RAM。

我们使用邻接矩阵表示图，一方面是空间上的一些考虑，另一方面我是身经百战了，根据我人生的经验，Mathematica 更适合处理邻接矩阵这种规则的结构。这个库的性能并不好，当然它本身也并未定位在性能上，更多人拿它做数学研究和原型。

奇怪的是，很久以后，才有人开始抱怨这个库的效率问题。实际上它一直都很慢，问题是过了很久才有人说出来。

问题在于计算机的速度一直在翻倍，而人们的期望也一直在跟进，但是这个库的基础数据结构，是平方级别的，所以在稀疏图上并没有办法很好地 scale。我们只好用线性的表结构重写了 Combinatorica。Benchmark 结果表明，图顶点数越多，新版在性能上的优越性越大。

我们从这个故事中学到：要想让程序跑的更快，只要等就行了。但是渐进复杂度始终很重要。

5.4 栗子：

本部分是 Section 3.6 中的多边形条带问题的后续。

寻找数量最少且覆盖整个网格的多边形条带的问题可以建模为图论问题，给每个三角形附一个图顶点，相邻的三角形用边连接起来，称为 dual graph 表示，这样就获取了进一步计算所需的全部信息。

但是在做这个之前，我们首先需要想办法把这个东西构建起来。一开始的做法：将每一个新加入的三角形与其他每一个三角形进行测试是否相邻。O(n^2)，太慢了。

构建一个数据结构：包含一个包含原数据中所有顶点的数组，其中每一个元素表示所有通过该点的三角形。当读入一个新三角形的时候，与相对应列表中的元素进行比较。这样只需要比较不到 20 个。

我们从这个故事中学到：就算是载入数据这样的基础问题，也可能成为算法开发中的瓶颈。操作大量数据的程序，一般都需要线性或近似线性的运行时间。

5.5 遍历图

遍历是最基础的图问题：系统地访问图中每一个点和边。比如迷宫，图的遍历算法应该能够找到一条出路，在效率方面，不会在中途停止，或重复访问同一个位置，在正确性方面，必须系统地进行遍历以保证走出迷宫，必须访问过每一个点和边。

遍历中每一个顶点有三种状态：未被发现，被发现但并未处理完所有边，已处理完毕。

遍历将会经过连通子图的每一个点和边：假设顶点 u 未被访问，其相邻点 v 已被访问，则 v 必然被访问，并且 u 会被访问。

5.6 广度优先搜索

广度优先搜索提供了一种访问图中每个点和边的机制，是许多简单高效的图算法的基础。

5.7 BFS 的应用

5.7.1 连通子图

"Six degrees of separation" 理论认为，世界上每两个人之间都有一条很短的关系。如果图中任意两个点都有一条路径，则说这个图是连通的。无向图中的连通子图指每一对点都有一条路径的最大点子集。许多帝国主义问题都能通过寻找或计数连通子图解决。连通子图可以通过 BFS 寻找（对每个未被访问的顶点执行 BFS）。在 Section 15.1 中，我们会讨论有向图的强连通和弱连通问题。

5.7.2 着色问题

顶点着色问题：给图中每一个点着色，要求任何一条边的两个端点颜色都不同。最简单的方案是给每个点着上不同的颜色。那么加一个要求：所用的颜色越少越好，如果一个图用两种颜色就能解决问题，那么说这个图是 bipartitie 的。该问题经常应用在规划问题中（如编译器的寄存器分配），关于该问题的解决方案和应用详见 Section 16.7。

我们可以使用 BFS，每当到达一个新顶点便将其设置为与其父元素不同的颜色，并进行检查，确保没有出现冲突。

5.8 深度优先搜索

5.9 DFS 的应用

5.10 有向图中的 DFS

5.10.1 拓扑排序

5.10.2 强连通子图