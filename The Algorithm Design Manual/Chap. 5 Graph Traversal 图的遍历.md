###Chap. 5 Graph Traversal 图的遍历###

图在 CS 中很重要，交通、人际关系、网络等等许多东西，只要图一种数据结构都可以解决。图几乎可以表示任何关系。

高效使用图算法的关键在于正确建模问题。熟悉更多图的算法问题比理解特定图算法的细节更重要（何况第二本书给你提供了实现，但是前提是你知道问题的名字）。本章描述图的基本结构和遍历操作，Chap. 6 会涉及最小生成树等高级图算法。

5.1 图的口味

一个图 G = (V, E) 定义为点的集合 V 和一个 V 中（有序或者无序）的点对边的集合 E。图的基础属性有如下几个，这些属性允许我们用图抽象、分析并表达对实际问题的建模：

* 有向/无向。对于 (x, y) ∈ E，(y, x) ∈ E，则说图是无向的。

* 带权/无权。对于最短路径问题，无权图是找边数最少的路径，可以使用 BFS 完成，带权图则需要使用 Chap. 6 中描述的更加复杂的算法。

* 简单/复杂。某些类型的边会使图的处理更加复杂，比如只涉及一个点的 self-loop (x, x)，或者在图中出现多次的 multiedge。不存在这类结构的图叫做简单图。

* 稀疏/密集。当只有少数点对属于边的时候图是稀疏的，其标准并没有明确的规定，但是稀疏图的边数一般是线性的，密集图一般是平方级别的。

* Cyclic/Acyclic。不包含任何循环的图称为 acyclic 图。例如树是连接、无循环的无向图。DAG - Directed acyclic graph，经常出现于规划问题。许多 DAG 算法的第一步一般是拓扑排序。

* Embedded/Topological。以几何位置定义点的图称其为 embedded，一般来说这种图的边由其依赖的图形隐式定义。

* 显式/隐式。某些图的应用并非是显式构造一个图之后遍历，而是在使用的时候隐式建立，例如 backtrack 搜索，这种情况下可能会方便一些，因为并不需要存储全部图。

* 有标签/无标签。有标签图中，每一个点都有一个唯一的名称/标识符。标签可以用来解决图的等价性问题（使用 backtracking，给两个图中的点标记 label）。

5.1.1 朋友关系图

人们的许多有趣的方面和行为以关系图的属性体现出来。关系图是稀疏的，同时其中存在若干个问题：如果我是你的朋友，是否意味着你也是我的朋友？两个朋友之间有多近？我是我自己的朋友么？朋友之间的地理关系怎样？“朋友的朋友”是一种什么关系？etc.

PS：在朋友关系图和疾病传染图等应用中，标签很多时候并不重要，人们仅仅是一个序号，当然你会说我是一个名字，不是序号——跟做算法的人撕去吧。

5.2 图的数据结构

这个问题上有两个选择：邻接表和邻接矩阵，选择正确的数据结构对性能很重要。邻接矩阵可以高效解决某一条特定边是否在图里的问题，支持高效的增删边操作，但是对于稀疏图空间效率不高（有一些奇技淫巧但是牺牲了简单性）。邻接表需要有指针，并不能快速判断两点间是否有一条边，但是可以在设计算法时避免这种问题。

大多数情况下我们使用邻接表。

在数据结构的具体设计上，我们在图中存储总顶点数，用顶点 ID 表示顶点，使用链表数组存储边。对于 insert_edge 函数，我们把新的边插入到链表头部。关键问题是方向性，我们加入了一个 bool directed 参数，在为 false 时会对反方向递归调用一次本函数。

对于通用图数据结构的具体实现，我们推荐 LEDA 和 Boost，分别在 Section 19.1.1 和 Section  19.1.3 中描述。它们强大，有点笨重（慢），然后定制性不是很好。

5.3 栗子：我是摩尔定律的受害者

I wrote Combinatorica.

Pardon? whaaat?

www.combinatorica.com，一个 Mathematica 下的图算法库。由于其运算模型和解释开销的原因，Mathematica 的效率是个问题，比如比 C 代码慢几千倍，甚至不支持数组的常数写操作，并且吃内存，1990 年我写这个库的时候得要 4MB RAM。

我们使用邻接矩阵表示图，一方面是空间上的一些考虑，另一方面我是身经百战了，根据我人生的经验，Mathematica 更适合处理邻接矩阵这种规则的结构。这个库的性能并不好，当然它本身也并未定位在性能上，更多人拿它做数学研究和原型。

奇怪的是，很久以后，才有人开始抱怨这个库的效率问题。实际上它一直都很慢，问题是过了很久才有人说出来。

问题在于计算机的速度一直在翻倍，而人们的期望也一直在跟进，但是这个库的基础数据结构，是平方级别的，所以在稀疏图上并没有办法很好地 scale。我们只好用线性的表结构重写了 Combinatorica。Benchmark 结果表明，图顶点数越多，新版在性能上的优越性越大。

我们从这个故事中学到：要想让程序跑的更快，只要等就行了。但是渐进复杂度始终很重要。

5.3 栗子：

TODO

我们从这个故事中学到：就算是载入数据这样的基础问题，也可能成为算法开发中的瓶颈。操作大量数据的程序，一般都需要线性或近似线性的运行时间按。

5.4 遍历图

遍历是最基础的图问题：系统地访问图中每一个点和边。比如迷宫，图的遍历算法应该能够找到一条出路，在效率方面，不会在中途停止，或重复访问同一个位置，在正确性方面，必须系统地进行遍历以保证走出迷宫，必须访问过每一个点和边。

遍历中每一个顶点有三种状态：未被发现，被发现但并未处理完所有边，已处理完毕。

遍历将会经过连通子图的每一个点和边：假设顶点 u 未被访问，其相邻点 v 已被访问，则 v 必然被访问，并且 u 会被访问。