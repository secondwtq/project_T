##Chap. 6 Weighted Graph Algorithms 关于带权图的算法##

---

**Chap. 5** 中所讲的数据结构和遍历算法是图操作的基础，这些算法都是针对无权图的。带权图的世界与之大不相同，比如：无权图中的最短途径问题，BFS 就可解决，带权图则要复杂很多，但是其应用同样也更为广泛。当然 Chap. 5 中的算法对带权图还是基本适用的，本章中我们会明确其适用范围等问题，并会介绍最小生成树 MST、最短路径、最大流量等若干较复杂的算法，需要注意的是，它们大多属于优化问题。

本章中我们使用邻接表作为数据结构，entry 是链表的数组，每一个节点（`edgenode`）包含其终点索引，权值和 `next` 三个字段。

6.1 最小生成树 MST

对于图 G = (V, E) 的一个生成树（spanning tree），是指构成一个连接所有顶点 V 的边 E 的子集。MST 即是指总权值最小的生成树，特定图的最小生成树可能不唯一（如果所有边权值不相等，则 MST 唯一。对于无权图来说所有生成树都是 MST）。MST 可解决用最少量的路/线/管道连接若干城市/房子/岔路等问题。其他应用在 **Section 15.3** 中介绍。

本章介绍的 MST 算法着重体现了贪心启发的最优特性。

6.1.1 Prim 算法

Prim 算法从某个特定点开始，向周围生长直到覆盖所有点。Prim 算法是贪心算法，其生长方式是寻找当前树外围边中权值最小的边加入树中（即局部最小值）。Prim 算法的正确性可以反证法证明，假定存在图 G，对其运行 Prim 算法结果并非 MST，意味着在构造树中的某一步出现了问题 blablabla。并且由于当前树外围的边端点之一并不在树中，因此不会出现循环。

TODO: 实现

Prim 算法的效率取决于其数据结构。理论上来说是 O(mn) 的（n 次迭代，每次测试大概 m 个边）。我们改进的实现则并不必每次迭代都测试 m 个边，只需要 O(n^2) 时间。这是利用数据结构改善算法性能的栗子。要是再应用优先队列的话，可以再优化到 O(m + nlgn)。

6.1.2 Kruskal 算法

Kruskal 算法和 Prim 算法一样是贪心算法，但是它并不从特定的点开始，并且在稀疏图中效率一般更高。Kruskal 算法每次选择权值最小且两个端点并非处于同一集合中的边加入到树中，逐渐建造 conntect component，并连接为 MST。其证明与 Prim 类似。

Kruskal 算法需要 O(mlgm) 时间排序边，之后通过 m 次迭代 DFS/BFS 进行测试，总共 O(mn) 时间。而使用下面要讲的并查集数据结构对测试过程进行优化的话在稀疏图上可以达到 O(mlgm) 的，比 Prim 要快。这依然是数据结构的作用。

6.1.3 Union-Find 并查集

6.1.4 MST 的衍生

* **最大生成树**。用于解决电信如何布线的问题，只要把权值取反即可。

    需要注意的是虽然 MST 在负权值情况下可以 work，但是最短路径等算法并不一定是这样子。
    
* **最小积生成树**。lg(a * b) = lg(a) + lg(b)，把权值用对数处理一下即可。

* **最小瓶颈生成树**。最小化所有边权值之和的最大值。当权值代表成本、容量或强度等属性时有一些应用。实际上每个 MST 都满足该条件。

还需要注意有两种问题不能用本章的方法解决：

* **Steiner 树。**允许加入新的点，最小 Steiner 树问题在 **Section 16.10** 中讨论。

* **低度生成树。** 最小化树中度数最大点的度数。最简单的低度生成树是遍历所有点的一条简单路径，称为 Hamiltonian 路径，在 **Section 16.5** 中。