##Chap 3. Data Structures 数据结构##

---

对性能差的程序进行数据结构的替换，如同给病人进行器官移植。对于 ADT 的实现进行移植，并不影响程序正确性，但是最好还是在最开始就选好数据结构。在学习高级内容之前最好先打好基础，因此本章**聚焦三种基础 ADT：容器，字典，优先队列**。

###3.1 连续与链式数据结构###

根据是基于数组还是指针，数据结构可以分为连续分配的数据结构（占用单块内存，包括数组、矩阵、堆、蛤希表等），链式数据结构（占用分散的若干块内存，使用指针连接，包括链表、树、邻接表构成的图等）两种。两者之间各有利弊，并且比你已经知道的事情更加复杂微妙。

数组是最基础的连续数据结构，可用街区中的房子做比喻。数组具有常数时间随机访问、节省空间（不包含额外指针），内存局部性等优点。

其缺点是不能在程序运行过程中调整大小。动态数组可以解决这一问题，其在空间用尽时分配双倍的空间并复制原数据。分析表明，在动态数组多次扩张的过程中，平均每个元素仅仅被移动了 2 次，动态数组不能保证最坏情况下的常数访问时间。

指针是链接链式结构的结构，一般来讲，存储变量的指针，灵活性比存储变量本身更高。链式结构中的 nullptr 表示结构的终止或未赋值的指针。链式结构中需要存在存储数据的字段，和若干指向其他节点的指针字段，并且需要用一个指针指向结构头部以供访问。链式结构需要用于存储指针的额外空间。

链表是最基础的链式结构，其三个基础操作：搜索，插入，删除。双链表结构简化了某些操作，增加了空间占用。

链表的搜索可以用迭代和递归两种方式实现，递归思想：若 x 位于链表中，则它一定在当前元素或者链表余下部分中。链表的插入很适合练习指针，删除操作更加复杂（需要找到前驱节点，并且需要处理删除第一个元素的问题）。

书中对链表节点引用使用了双层指针（可以直接修改头节点变量的值之类的），简化了部分代码的逻辑。

对比数组与链表：链表不会出现下标越界，插入删除操作更简单，在处理较大记录时操作指针更方便。但链表占空间大，不能随机访问，内存局部性和 cache 性能差。

###3.2 栈和队列###

容器：允许存取任意内容数据的数据结构，通常以其支持的数据获取顺序定义。相对于另一个名词，字典：利用键值内容获取数据。

栈：LIFO，实现简单，效率风骚，实例存在于许多地方，并且在数据获取顺序无所谓时也可以用，在递归中比较常见。队列：FIFO，公平地处理服务的等待时间（减少客户端等待的时间，并不减少总时间）。实现起来稍微麻烦，适合于需要保证获取数据顺序的地方。队列也用于 BFS。

栈和队列都可以用数组或链表实现。

###3.3 字典###

数组以索引访问内容，字典则**以内容访问内容**。字典**最基本的功能**有搜索、插入、删除三个。对于某些实现，还可以提供求最值、求某一键的前驱、后继等功能。

字典可以用来解决许多常见的数据处理问题。在使用的时候我们只需要考虑接口，所要解决的问题，不需考虑内部的数据结构细节。

**最 naive 的实现是直接使用一个未排序或已排序的数组**，但是两者在支持不同操作的时间复杂度方面区别很大。字典还可以用单/双链表实现，需要注意的是在链表中不能使用二分实现 search，已排序的链表只能防止搜索不存在键的时间浪费。

###3.4 二叉搜索树###

对于数组/链表实现的字典，快速搜索和更新并不能同时满足。

***二叉树*** 的递归定义：或者是空的，或者有一个包含两个子树的二叉树，子树的顺序无所谓。二叉查找树则给节点加入了键，并规定其左子树的节点全部小于 k，右子树节点大于 k。这样二叉搜索树节点包含两个子树指针，一个数据值，可能还有一个母指针。支持的基本操作有搜索、遍历、插入和删除。

在实现查找、遍历等功能时，使用递归思想，因为节点的左右子树都是二叉搜索树，中序遍历可以实现按照顺序遍历树（前序和后序主要在处理表达式时使用）。在实现求最值功能时，沿左/沿右直走即可。

插入操作需要在递归查找操作的基础上，当子树指针为 null 时新建节点并添加上去。删除操作麻烦一点，要分三种情况，可以直接删掉的无子节点情况，直接提升子节点的只有一个子节点情况，需要把右子树换上去的有两个子节点情况。

使用 BST 实现字典，所有操作都可以在 h (height) 时间内完成，h 值 对于 n，理想情况下是对数级别的。

但是随机并不能完全解决问题，一般在插入和删除操作中执行调整，以保证树的平衡性，即平衡 BST，常见的有 Section 12.1 中的 红黑树 和 splay tree。和字典一样，平衡 BST 也应该当作黑盒使用。

###3.5 优先队列###

相对于排序，***优先队列*** 提供了更多灵活性（允许低成本的即时元素调整）。其支持的主要操作有插入、获取和删除最小值三个。

三个实现优先队列的尝试：未排序和已排序的数组，平衡 BST。这时建议加入一个指针指向最小值，这样查找最小值操作便可以 O(1)，而把获取最小值的操作分摊到删除操作中。

优先队列很有用，下面两个栗子都是讲优先队列的。优先队列的 ***堆实现*** 在 **Section 4.3**，其他实现在 **Section 12.2**.

###3.6 栗子：多边形带的划分###

计算机图形学中的几何模型通常用三角化的表面来表示，而瓶颈有时在数据传输而非渲染上。三角形可以用三个顶点表示，而对于相邻的三角形，用条带来表示更高效。

***问题：将网格分为全覆盖并且数量最少的多边形条带，属于图论问题。***

* 尝试 1：最简单的 heuristic，从随便一个三角形开始，左右扩展直到最后。又快又简单，就是得到结果很蛋疼。

* 尝试 2：greedy heuristic。找到最长的条带，然后处理掉，结果也不是最优的，但是把最长的条带去掉，剩下的面是最少的，比上面好一点。

    但是如此一来是平方级别的时间复杂度，因此为了效率，不应在每次删除条带之后重新处理一遍，而应采用某种数据结构将其存储起来，每次删除一个条带，只更新（缩短）相关的条带。候选的有：

    * 优先队列。下一次要处理的条带始终在队列顶端，并且队列需要资词更新条带长度之后的优先级调整，而为了实现更新面，我们还需要知道面的位置，这样还需要 ->
    
    * 字典。我们需要知道网格中每个面在队列中的哪里，因此应在字典中存储指向每个面的指针，将优先队列和字典结合起来。

这样程序时间复杂度 O(nk)，n 为总面数，k 为平均条带长度。

我们从这个故事中直到：对于大数据来说，只有 O(nlogn) 以下的算法可以接受。而正确的数据结构是获得足够性能最重要的一点。适当使用 heuristic 能带来很大的结果质量提升，具体效果取决于实际情况。本栗子的成果详见 ***[ESV96]***。

###3.7 蛤希与字符串###

蛤希是很有实际意义的字典维护方式，但是蛤希的应用不仅仅是字典，其原理是：对于数组来说，根据索引的访问是常数时间的。蛤希函数将键映射为（大）整数，一般是独一无二的识别号码。然后取模，效果就像那种轮盘一样。而在桶数量的值经推敲的情况下（与 2^i-1 相对较远的大素数），蛤希的分布应该相对平均。蛤希函数合适的话，效果一般会比较好。蛤希是随机化算法的典型。

####3.7.1 碰撞避免####

最简单的方法：**开蛤希**，链表数组。缺点：一堆的指针占空间。遍历耗时 O(n+m)。

另一种方法：**open addressing**，如果一开始的目标地方非空，则找另一个地方插入。最简单的是线性探测。注意开地址中的删除会很蛋疼，大概必须全部重新插入来保证正确性。遍历耗时 O(m)。尽管概念很简单，对蛤希表进行优化却很复杂，详见 ***TAOCP***。

####3.7.2 蛤希与高效字符串匹配####

对于许多应用（编译原理，搜索引擎，计算生物学），文本字符串是最基础的，字符串的特点是字符的顺序很重要。其中最基础的操作之一是子串搜索。

最简单的方法：brute force，O(nm)。最坏情况是平方，详见 Section 18.3。

Rabin-Karp 算法，基于蛤希，平均时间线性，随机算法，不提供时间保证。原理：对于蛤希值相同的字符串，其内容一般相同，实在不行就直接比对。这样便将子串匹配问题化归到 n-m+2 次蛤希值计算。还没结束，这样的话依然是 O(mn)。

对于原来的蛤希函数 H(S, j) = sum\[0-(m-1)](a^(m-(i+1))*char(s(i+j))，定义

H(S, j+1) = a(H(S, j) - a^(m-1)*char(s(j)))+char(s(j+m))

这样便可以在常数时间中计算下一段的蛤希值。

####3.7.3 蛤希与重复探测####

蛤希的关键：**用一个数字（能以常数时间操作的对象）代表较大对象**。而除了搜索以外蛤希也有很多应用（据说那个中国公司刚刚那个啥了的 *Yahoo!* 就是 hashing hashing hashing）。

* 网络爬虫的探测，是否抓了两个内容相同的页面。把内容蛤希掉相对于直接比较更有效。

* 探测源自网络的抄袭。相对更难（稍微改一下就蛋疼了），方法：对所有文档中长度为 w 的重复子串进行蛤希。最大问题：蛤希表的大小随文档增加。详见 ***[SWA03]*** 的描述。

* 确认文件是否未被修改。Cryptographic Hashing，确认获得的文件和原本一样。

####3.8 专用数据结构####

* **字符串**。一般用特殊结尾的字符数组表示字符串。**Section 12.3** 中的后缀树/数组用来进行字符串预处理，加速字符串匹配操作。

* **几何数据结构**。一般由点和区域集合构成，平面中的区域可以由线段构成，顶点数组表示的多边形表示。kd-tree 等空间数据结构根据位置组织点和区域以进行快速查找。详见 **Section 12.6**。

* **图**。图使用邻接矩阵或邻接表表示，这个表示方法对性能有很大影响。具体在 **Chapter 6** 和 **Section 12.4** 中。

* **集合**。集合操作的数据结构在 **Section 12.5** 中，union-find （集合划分）则在 **Section 6.1.3** 中。

####3.9 栗子：字符串####

（***TODO WIP*** 总而言之我没理解需求就是了）

人类基因组包含了造人所需的全部信息。也吸引了算法基础们的注意：DNA 序列是用字符串表示的，需要更好的算法解决字符串匹配等老问题，同时也有新的问题如 shortest common superstring（**Section 18.9**）。同时 DNA 序列串还很长，这样基础们就可以慢慢的做那个什么分析工作了，然后这个还很赚钱*（我去搞 IT 的笑搞生物的难道不是五十步笑百步？）*。

我在计算生物学中对一种处理 DNA 序列的 sequencing by hybridization (SBH) 技术很感兴趣。

***问题：搞出一种算法快速构造所有 2k 长度串。***

尝试：最简单的，将所有 n^2 对 k 串连接起来，然后逐个测试。

* 第一次，BST，查找耗费 O(logn) 次比较。跑起来之前，一直都很好。

* 第二次，蛤希表，跑起来之前，一直都很好。

* 第三次，后缀树（详见 **Section 12.3**），利用每次测试仅仅有一个字符 offset 的特点。跑起来之前，一直都很好。

    ——结果 Memory Limit Exceeded 了。

* 第四次使用压缩后缀树（详见 **Section 12.3**），线性空间，并不使用字符节点表示，而是直接引用原字符串。

不用担心，这次没事了。还有一些其他的问题，在 **Section 7.7** 中。

我们从这个故事中学到了：我们把单个重复操作，即字符串字符串搜索分离出来，之后优化其数据结构，从简单的 BST 开始测试，有问题则使用 profile，不断提高，绝不放弃。算法和人生一样，坚持是有价值的。（鸡汤都出来了）