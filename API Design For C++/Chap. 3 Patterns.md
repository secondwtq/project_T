## 模式

优秀 API 特点 -> **惯用法** -> 构建优秀 API 的技巧与原则。

你肯定知道设计模式，四人帮，但这并不是本章重点，我们讲的是在 C++ 中设计优秀 API 的模式。包括 Pimpl 惯用法、单例、工厂、代理/适配器/外观、观察者等。以及第 12 章可扩展性中的访问者模式。

### Pimpl 惯用法

`pointer to implementation`，避免在头文件中暴露私有细节，逻辑和物理上隐藏私有成员和函数的一种 C++ 特色桥接设计模式的特例变通方案。利用了 C++ 滋瓷前置声明结构的指针作为数据成员的特性。

方法：私有内嵌实现类。

	private:
	class Impl;
	Impl *m_impl;
	
需要考虑在实现类中放什么东西，是只放私有变量，还是把私有变量和方法都放进去，还是把所有东西都塞进去，接口再简单包装一层。书中推荐只放私有方法。这时注意：不能将私有虚方法隐藏在实现类中，必要时可以在实现类中增加公有接口指针以便其调用公有方法。

Pimpl 的优点有：利于信息隐藏，公有头文件更干净更清晰，保护闭源 API 专有性，避免用户访问数据成员；接口头文件不需要额外的头文件依赖，降低耦合；加速编译；由于接口类只有一个指针，也有利于二进制兼容性；也可以只在需要时惰性构造实现类实例。

缺点有：

* 开发者需要记得管理实现类实例，并且需要显式的指针间接访问，引入了可以忽略的性能问题以及多余的代码。

* 并且，编译器难以捕获 const 方法中对成员变量的修改（仅检测了 m_impl 指针？）。

* 复制语义是另一个问题，尤其是在实现类拥有指向公有类指针时更复杂。要么禁用复制，要么想办法处理，这是优秀 API 开发人员要付出的代价。

* 也可以考虑使用智能指针解决生命期问题，不过这样还是要注意智能指针的复制问题（也可以考虑 Copy on Write 指针？）。

C 语言中也可以使用类似的模式（不透明指针），就是常见的声明一个结构体但是不给定义，给一堆需要其参数的函数...

### 单例

实际上是更加优雅的全局变量。确保一个类仅存在一个实例，并提供对此唯一实例的全局访问点。控制对象的生命周期，支持线程安全，并避免污染全局命名空间。用于建模固有的唯一对象

但实质上仍是全局变量，会引入全局状态和依赖项，使得编写单元测试更难。所以要考虑好是否需要全局状态（四人帮甚至说过它们曾经计划从《设计模式》原列表中移除单例模式）。要在 C++ 中实现鲁棒的单例，难上加难。

首先你要有一个单例类，一般类里面有一个 `getInstance()` 之类的方法，每次调用返回该类同一个实例。由于 C++ 中 不同编译单元中非局部静态对象的初始化顺序未定义，因此使用非局部静态变量初始化单例较危险，应该在类的方法中创建静态变量。

私有默认构造函数阻止用户创建新的实例，私有析构函数阻止用户删除单例实例，如果需要客户创建单例子类的话可以声明为 `protected`。私有复制构造函数和私有赋值操作符阻止了单例的赋值。`getInstance()` 方法可以返回指针/引用，书中建议返回引用。

并且，利用局部静态变量初始化单例依赖于静态变量后进先出的销毁，如果单例在析构函数中调用其他单例（比如日志）就可能出现问题。可能的应对措施：销毁后必要时恢复，延长特定单例寿命或放弃单例的销毁。

上述方法也并不**线程安全**，在多个线程同时调用单例方法时会出现竞态条件。可以加锁，但是每次调用时都加锁开销较大。可以采用双重检查锁定模式，但是也并不能保证通用性。可以考虑使用 volatile，也不能完全解决问题。如果是 POSIX 的话考虑使用 `pthread_once()`。或者不要使用惰性初始化，而是在启动时，`main()` 之前，静态初始化，显式初始化，使用互斥锁保护初始化调用等，指定所有单例的初始化顺序。但是你首要考虑的应该是是否需要在如此多样的平台下支持线程安全，毕竟 C++ 对并发貌似缺乏内在滋瓷。

另一种模式允许创建类的多个实例，但是共享相同的静态数据，对实例中方法的所有调用都会返回相同结果。叫做**单一状态**（monostate）模式。实际上是单例的另一种形式，单例仅允许创建一个实例，强制了唯一性的结构，单一状态共享同一份数据，强制了唯一性的行为。缺点在于不能子类化任何静态方法，不能通过 ctor/dtor 执行初始化或清理工作（可以考虑引入 `initialize()` 之类的方法，但是需要显式初始化）。

另一个概念是在对象创建时在构造函数中将**依赖注入**，而不是让其依赖单例的唯一访问点。用 setter 或者可复用接口注入也行，但是注入是依赖容器的工作了。这样避免了一些单例的缺点，还可以把依赖项替换成 stub/mock 版本供测试等。

有些需求下单例是需要避免的，比如把一个 notepad 从 SDI 变成 MDI，全单例就很麻烦。应该尽早考虑引入“session 会话”“context 上下文”这样的概念，用一个实例维护需要的状态，这样就算出现问题只要改掉一个单例就可以了，也叫“**工具箱单例**”。

### 工厂

### API 包装器模式

这组模式用于编写基于另一组类的包装器接口。可以用来隐藏第三方依赖库、包装遗留代码等，缺点是可能引入可以忽略的性能问题... 这套模式根据包装层与原始接口的差异递增分了三个层级：代理、适配器、外观。

* **代理模式**：单一组件包装器，为另一个类提供一对一的转发接口，代理类和原始类有相同的接口。代理类存储原始类的，一般是指针，可能是副本，将方法重定向到原始类对象中同名方法。需要维护代理类接口与原始类接口的一致性。

	可以用于实现原始对象的惰性实例、保证访问控制、线程安全、加入调试或“dry run”功能、支持引用计数/Copy on Write 资源共享的享元用法、应对原始类被修改的适配器用法等。

* **适配器模式**：单一组件包装器，将一个类的接口转换为一个兼容但可以不相同的接口。分为组合适配器（对象适配器）和继承适配器（类适配器）两种，继承适配器如果不需要暴露原始类接口的话一般用私有继承。

	用于保持 API 一致性（命名约定，参数顺序，坐标系统，使用习惯 blablabla），包装依赖库，转换数据类型，暴露不同的调用约定等。

* **外观模式**：使得底层子系统更易于使用为一组类定义一个改进了简化的更高层次的接口，但仍能支持对底层子系统的访问（类似于便捷 API，也可以做成“封装的外观模式”，完全分离底层和公有接口）。外观模式相比适配器模式，对类的结构进行了简化（而不是保持不变）。使用外观模式封装的 API 只需处理一个对象并且接口还更简单。

	用途：隐藏遗留代码，创建便捷 API，创建可替换子系统、置换功能的简化功能 API。

### 观察者模式

复杂的任务需要几个对象合作完成，使用观察者模式能够避免编译时的紧耦合，避免类之间的依赖和循环依赖，增强通用性，支持运行时动态添加新的依赖。

栗子：MVC 架构。支持应用程序的功能模块化，并且实现了模型与视图组件的隔离，可实现多个 view，并且避免多份重复模型代码，解耦简化了业务逻辑的单元测试，允许逻辑开发者与 GUI 开发者并行工作。在 Qt、Cocoa、Swing、Microsoft Foundation Classes 中都有应用。其中 view 能调 model，但 model 不能反调 view，model 不应获得其他部分的编译时信息。要想让 view 反映 model 的变化，需要采用观察者模式。

观察者模式的两个概念：主题/subject/发布者和观察者/observer/订阅者。观察者模式分为基于推和基于拉的，两者区别在于发布者 notify 观察者时，是否给出所更新的具体信息，拉式观察者需要自行查询细节。拉式观察者的接口更加简单通用，书上说适合发送较大 bunch 的数据，推式适合小数据。

缺点：可以忽略的性能损耗。但是在销毁 observer 之前需要取消订阅。