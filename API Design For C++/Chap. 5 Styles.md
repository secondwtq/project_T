## 风格

开始侧重如何使用 C++ 特性设计 API。本章主题是 API 的风格，即如何表现 API 功能，采用何种形式调用 API 提供的功能。注意，提到 API 不一定全都是面向对象的，本章会介绍 4 种风格：

纯 C（一组自由函数，辅助数据结构与常量），面向对象 C++（对象，继承，封装，多态），模板（泛型编程与元编程），数据驱动（将参数以数据结构打包并和命令一起发送，而不是直接调用函数）。

栗子：FMOD API，一个用来创建和回放交互式音频的商用库，提供了纯 C、C++ 和数据驱动 API。

---

### 纯 C API

无封装和继承层次等概念，语言特性受限。栗子：标准 C 库，Windows API，UNIX API，GLib，NSPR，大多数开源图像库等。

特性：内置类型、数组、指针。typedef (enum?)、结构和联合、全局自由函数、预处理器。

优点：适于与纯 C 项目集成，有利于维护不同版本的二进制兼容性。

因为没有命名空间，所以为避免命名冲突，公开函数和数据结构应该使用公共前缀。实现中的符号可以通过静态等内部链接方式隐藏（C++ 中应使用匿名命名空间）。

注意，C++ 一般兼容 C，但 C++ 的类型检查更严格，所以建议在最后用 C++ 编译器编译一下并修复给出的警告和错误。

C API 一般也能在 C++ 中使用，但是需要注意不能包含任何 C++ 保留字（如 `class`），并且能够通过 C++ 编译器的类型检查。并且由于 C++ 具有函数重载等功能，因此链接时存在 name mangling 问题，因此需要将头文件包在 `#ifdef __cplusplus` 所包裹的 `extern "C"` 块中（C 编译器无法解析）。

在编写纯 C API 时，可以模仿 C++ 对象模型，定义一个 struct 作为数据结构，相关函数以其名称作为前缀（纯 C API 无法将名称作用域限制在类型声明中），并且接受一个相当于 `this` 的指针参数。也可以进一步改为不透明指针：

	typedef struct Stack *StackPtr;
	
注意 C 中没有构造函数和析构函数等，因此任何对象都需要客户显式初始化和销毁。

也可以使用 C++ 进行实现，但是提供一个纯 C 包装（可能比较简单小型）。FMOD API 就是这么干的。这里使用了多层的函数命名空间约定，所有 FMOD 函数都以 `FMOD_` 开头，所有系统级调用都以 `FMOD_System` 开头。

---

### 面向对象 C++ API

面向对象设计的思考方式比较自然。4.6 节讲解了面向对象中的关键概念，不过 C++ 中许多特性严格来讲并非面向对象的概念。

在概念上，建模的物体实体和过程一般可以用对象描述，因此面向对象编程核心人物是识别问题空间中的关键对象并确定其之间的联系。技术上使用对象将一个概念单元中的所有数据和方法都封装在一起（创建了一个唯一的命名空间）。面向对象使用对象并非动作来建模，同时允许继承、封装等。

但是面向对象也有其缺点，大多数是因为滥用面向对象。首先，继承有一定的复杂性和微妙性，并且由于子类不必重新声明父类成员，因此继承层次较深时只看头文件（不用 docxgen 等）就难以获得对象的所有接口。并且，面向对象 C++ 的二进制兼容性较差。

FMOD 的 C++ API 利用了 namespace，所有类和函数都在 FMOD 命名空间中，头文件文件名与 C 头文件相同，但是扩展名是 `.hpp`。

---

### 基于模板的 API

模板支持使用泛化的、尚未具体指定的类型编写函数或类并进行实例化和特化。可用来编写编译时生成/执行代码的程序（即元编程），可用在循环展开、预计算级数、编译时打表、扩展递归次数预先确定的递归函数等。在编译时进行一些工作，改进运行时性能。模板 API 的栗子有：STL，Boost、Loki（实现了各种设计模式，非常优雅，同时推荐其所滋瓷的书《Modern C++ Design》（貌似现在也不 modern 了））等。

可以使用 `typedef` 简化模板的使用：

	typedef Stack<int> IntStack;
	
有些 approach 使用预处理器宏代替模板，代码丑陋，没有类型检查和作用域等，同时全部展开到一行中难以调试。建议只在纯 C API 中使用。

使用模板有利于去除冗余、实现静态（编译时）多态、对特定类型编写特化进行优化或定制实现等。但是也有几个很突出的缺点：要进行模板的特化，类模板定义必须出现在公开头文件中，暴露内部细节（这是给 API 开发带来问题的一个主要原因），增加编译时间，使代码膨胀（每包含了一个这样的头文件都要重新编译并将代码添加到目标文件中），可以考虑使用显示实例化将实现隐藏在 .cpp 文件中（见下一章）。模板的错误信息也很蛋疼，并且直接影响客户的使用。并且还需要考虑静态多态和虚方法多态在运行时开销和代码体积之间的平衡。

---

### 数据驱动型 API

通过每次运行提供不同的输入数据，可以执行不同的操作，也叫消息传递 API 或基于事件的 API。不再依赖于提供方法调用的对象，而是提供接受命名命令和参数列表的一般化例程。也可以将命令保存在文件中，使用程序解析，而不需要重新编译。

	Result command(const std::string& cmd, const ArgList& args);

数据驱动型 API 最主要的优点是能将程序的业务逻辑抽象到易编辑的数据文件中，在不重新编译的情况下改变程序行为。并且可以支持独立设计工具，对于 API 未来可能发生的变化容错性也更强（不改变公开方法自身的签名，如果利用命令的参数支持不同版本，本质上是模拟重载），支持数据驱动型测试技术（编译一个驱动，编写若干包含命令和断言的测试）。

缺点是运行时开销较大，并且头文件无法反应实际接口（可以利用文档弥补，API 是一组头文件和文档的组合），无法从编译时检查中获益，需要更多的测试等。

数据驱动型 API 更适合（无状态的）数据通信接口（通道），松散耦合组件之间的消息传递，典型栗子是 Web 服务。并且也可以将 Web 服务映射到数据驱动 API 中（当然还不是很方便与下层协议解耦）。

	d = new DiggWebService();
	d->Request("digg.getInfo", ArgList().Add("digg_id", id));
	
前面回避掉的 `Result` 和 `ArgList` 等问题。实际上是“保存值的对象”，貌似依赖于一种 `any` 类型，一般称为“可变类型”，Python 等弱类型语言会比较方便一些。允许不同类型值的存储，获得值的类型，并且将值转换为另一个类型。包含 `any` 概念的包有：`Qt::QVariant`，`boost::any`，`LLSD` 等。

实现方法有：使用联合（如 Win32 `VARIANT`，需要一个额外变量指示类型），继承（`QVariant`，每个类型用从公共抽象基类派生的类表示），`void *`（同样需要额外变量，但是类型安全性最差）。本书所附代码中使用继承方法实现了一个值类型。（*@`JS::Value`*）`ArgList` 定义为 `string` 到 `Arg` 的映射：

	typedef std::unordered_map<std::string, Arg> ArgList;

FMOD 的数据驱动部分 API 并没有覆盖前述所有概念，但是可以将逻辑保存在数据文件中并在运行时加载。

---

三种风格对比：

	func(obj, a, b, c);
	obj.func(a, b, c);
	send("func", ArgList().add(a).add(b).add(c));
